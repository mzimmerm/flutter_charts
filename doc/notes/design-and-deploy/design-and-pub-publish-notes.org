#+OPTIONS: toc:3
#+TODO: TODO IN-PROGRESS IN-PROGRESS-NOW LATER DONE NOTE


* Bugs and issues - flutter_charts
- [X] After tons of layout changes, the whole grid disappeared from the line chart only.
- [ ] The stock charts example contains a bug which reverts the series on the negative values - both negative dataRows, and dataRowsColors must be reverted for the chart stacks to show in intended order (black, green grey red from top). But even then, dataRowsLegends are incorrect. 
- [X] Chart area needs clipping in the application
- [X] https://github.com/mzimmerm/flutter_charts/issues/5 - Coloring support: Make line chart dot colors settable
- 
 
* NOTE Layouter general function

*The one-pass layout method in a Container* (or in Layouter mixin if we put Layouter on Container) should work like this:

1. *SizeConstraint is passed down* to layout call.                                               parent context: ~Size childPreferredSize = child.layout(sizeConstraintDefinedByParent)~  <= side effect: child.size is set (=childPreferredSize) 
2. *PreferredSize is returned up* from layout and also stored on child (happens also in 1).               
3. Once we know all children sizes:
4. Parent decides, based on it's layout algorithm,
   the size and position to actually give to each child :                                    parent context: calculateAndSetActualChildrenLayoutSizesAndOffsetsInSelf() <= layoutSize effect: child.layoutSize [overrides previous value] and child.offset (within parent) [new value] is set on each child. this.layoutSize and this.offset is set on me (parent)
6. Step 4 includes *Parent sets actual layoutSize and position down on child*.


#+BEGIN_SRC python
  def layout(Size sizeConstraintFromParent):     # 1. sizeConstraints go down (as this is called in parent context)
    if this is leaf:
      this.layoutSize = calculate own layoutSize (may be e.g. size of rectangle if this is a rectangle) if not withit SizeConstraint, exception???
      return this.layoutSize                # 2. sizes go up
    else:
      for child in children:
        # All children are offered the full layoutSize of parent. If greedy, that is a problem 
        Size layoutSize = child.layout(constraintFromParent) # ignore return, we have it in side-effect
      calculateAndSetActualChildrenLayoutSizesAndOffsetsInSelf()
      return this.layoutSize ????


  # For example, for flow layout, each child is given the layoutSize it previously asked, and moved by predecessors layoutSizes.
  # !!!!!!!!!!!!!!! this replaces applyParentOffset
  def calculateAndSetActualChildrenLayoutSizesAndOffsetsInSelf():
    Offset currentOffset = 0
    Size myLayoutSize = 0
    for child in children:
      child.layoutSize = child.layoutSize         # Size goes down - no change in one pass layout
      child.offset += currentOffset   # 3. Actual position goes down
      currentOffset += new Offset(child.layoutSize.width, 0) # just shift next child some more to the right.
      myLayoutSize = currentOffset + child.layoutSize
    this.layoutSize = myLayoutSize
#+END_SRC   
* NOTE How are todos used in code

- todo-1 long term low priority
- todo-2 long term higher priority
- todo-10 release-blocker (created typically during a new work in progress)
- todo-11, todo-12 todo-13 - work in progress (implies todo-10), higher number is higher priority or more immediate. *So -13 is the highest ever priority.*
** ~cd flutter_charts~ - Implied default directory
* NOTE *Pub - Publish flutter_charts* : Workflow of publishing new version on flutter_charts on https://pub.dartlang.org
** ~flutter pub upgrade; flutter pub get~
Upgrades packages listed in ~pubspec.yaml~ to the highest version listed (and also available on pub) 
** Test app from IntelliJ and ~tool/test/run_all_tests.sh~
** Ensure pub-required files exist: pub the following file in project to show the correct tabs on pub
*** Tab README.md    - Needs the file
*** Tab CHANGELOG.md - Needs the file
*** Tab Example      - this tab appears if the project has and ~example/lib/main.dart~ file ~file://./../../../../flutter_charts/example/lib/main.dart~ exists
*** Tab Installing   - shows automatically
** *pubspec.yaml*: - Increase version number "version: 0.X.Y"
** *CHANGELOG.md*: - Add comment section for new version and description of changes.
** *README.org*: add changes, and *make sure image links point to this link: ~file:/doc/readme_images~ as, for example:* [ [ file:doc/readme_images/README.org_IMGID.png ] ]

The reason is, the published package website only allows links to the ~doc/readme_images~ directory. So all images must be there.

*From web: Images are not allowed on pub  https://pub.dartlang.org. When new images are added to README, we need to put the images somewhere outside pub, README.md must only contain links to the images. We decided to store images in a special directory doc/readme_images, and point to then via github*. 

This is the process of adding images to README.org, which survives conversion to README.md, and publishing on pub:

- [ ] Add an image to README.org using the regular image capture.
- [ ] Show the image links directly
- [ ] Rename the images to a readable names, both on disk (wdir-) and in org file, for example: =README.org_20180618_000741_0oAyud.png= to =README.org_iterative-layout-step-4.png=
- [ ] Move the image from ~flutter_charts~ to ~flutter_charts/doc/readme_images~
- [ ] Change the links in org file by changing =file:= to =file:doc/readme_images/=
  - [ ] in the org file, this look like =file:doc/readme_images/README.org_iterative-layout-step-4.png=

** *README.org*: Convert to *README.md* 

To convert *README.org* to *README.md*, we need to do a few extra steps for README.md image links to be readable on https://pub.dartlang.org.

1. Note: Ensure README.org file which has the "Table of contents" heading marked as :TOC:noexport: (e.d. TAble of contents :TOC:noexport:) - this causes the TOC update on every save.
   - The :noexport: is currently needed , otherwise error Unable to resolve link: "link-converted-from-first-heading"
2. *README.org*: Export org to md: ~C-c C-e m m~ in the org file to create the generated md file
3. *README.md*: Delete the TOC generated by the org -> md export, the whole section , including the header named "# Table of Contents" (still needed with :TOC:noexport:)
4. *README.md*: Delete the <a id="YYYY"></a> generated by org conversion: ~delete-matching-lines <a id=~
5. *README.md*: Generate md-native TOC:
6. Cursor on top
7. ~M-x: markdown-toc-generate-toc~
8. *README.md*: *NOT NEEDED in 2021-12* Fix image links in the README.md - links must be converted from the first version to the second: 
  #+BEGIN_SRC markdown
  -![img](doc/readme_images/README.org_20171102_180657_27063rZs.png)
  +![img](https://github.com/mzimmerm/flutter_charts/raw/master/doc/readme_images/README.org_20171102_180657_27063rZs.png)
  #+END_SRC

  *README.md*: This is achieved with: ~M-x replace-string~ then ~doc/readme_images/~ ~https://github.com/mzimmerm/flutter_charts/raw/master/doc/readme_images/~
** *README.md*: on https://github.com/mzimmerm/flutter_charts - check if image links in README.md have a full path
** ~flutter format [--dry-run] .~ # Run the standard formatter. Dot is for currdir
** ~flutter analyze~ # Analyze and fix errors

** ~flutter clean; flutter pub upgrade; flutter pub get; flutter clean; tool/test/run_all_tests.sh~ which runs ~flutter test~ and integration tests. Also see https://flutter.io/testing/
** TODO Run Dart Doc creator - this can fail on dependencies, so fix it!
See https://dart.dev/tools/dartdoc
** ~git add .; git commit; git push~
** ~flutter pub publish --dry-run~
** Once the above has no errors or warnings: ~flutter pub publish~
** The above will ask for authorization (will generate an auth link and go to the link in browser)
** Message: The pub client has been successfully authorized. You may now use it to upload packages and perform other tasks.

This just finishes up the publish.

** Check the published package: https://pub.dartlang.org/packages/flutter_charts
*** Make sure that:
- all tabs look good, 
- links in README and CHANGELOG work,
- check if doc was generated
- Go over issues in the analyses tab: https://pub.dartlang.org/packages/flutter_charts#-analysis-tab-
** Test the package that was just published
*** ~cd flutter_charts_sample_app; flutter pub upgrade; flutter pub get; flutter run~

* DONE Add ability to create a Table of Contents to README.org
- [X] Install toc-org package
- [X] Add to init.el
#+BEGIN_SRC elisp
(if (require 'toc-org nil t)
(add-hook 'org-mode-hook 'toc-org-enable)
(warn "toc-org not found"))
#+END_SRC
- [X] Every time README.org is saved, first heading with a :TOC: tag will be updated with the current table of contents.
- [X] So nothing special need be done after the above is configured.

* Terminology and Selected Classes

- (Presenter)Leaf       :: The finest visual element presented in each  "column of view" in chart - that is, all widgets representing series of data displayed above each X label. For example, for Line chart, the leaf would be one line and dot representing one Y value at one X label. For the bar chart, the leaf would be one bar representing one (stacked) Y value at one X label.
- Classes: Presenter, LineAndHotspotPresenter, VerticalBarPresenter, PresenterCreator
- Painter               :: Class which paints to chart to canvas. Terminology and class structure taken from Flutter's Painter and Painting classes.
- Classes: todo

* Older Design Notes

** Towards a new, suggested ~InternalChartData~ class - this is the class Flutter Charts will work from at it's core. *This may change significantly.*

First, let me summarize that current (unexpressed) constraints on  the current ~ChartData.dataRows~ - in essence, all corresponding list lengths must be the same:

1) Along the x axis (row wise)   : (each row in dataRows).length is the same 
2) Along the x axis (row wise)   : (each row in dataRows).length == xLabels.length 
3) Along the y axis (series wise): dataRows.length == dataRowsColors.length == dataRowsLegends.length

Basically, the ~dataRows~ member assumed to be an array (list of rows of equal length)

So towards the future, the more I was thinking the way the layouting may work, the more I am sure it is best to keep 1) for sure, and maybe 3), but drop 2) for sure to support uneven steps and skipped labels. And in all case I kept arriving at thinking the layouter would eventually convert any ~List<List<Point>>~ to a list of Y values ~List<List<double>>~ and extract the X values under each point so we have List<double> xValues. I would like to note that this structure can be made in all respects equivalent to  ~List<List<Point>>~ - we can always write adaptors in either direction. 

So I'd like to support the internal structure of ChartData as described below, and all external data in different formats/structure would have to provide convertes; this project would probably provide some basic adaptors (I am thinkig to support some basic (e.g. some Higchart type) JSON data formats out of the box.

Next, goals and non-goals of this change.

*Current goals of the ~InternalChartData~ class:*

- Define a data source class used on the the low end of chart layout. 
- Define the data source class in terms of lowest level primitives: Because in the end, all paint operations operate only with Dart ~double~ (for Y values, and Distanced X points) and Dart ~String~, we only use those primitives.
- Still allow for a simple, no frills way of clients defining their own X and Y labels directly, similar to the current ~ChartData~ 
- Provide a sufficient description for data defined as any "reasonable" object to be convertable to  ~InternalChartData~ through adaptors.
  - Data Adaptor Examples: 
    - X values is a List<String>, Y values is a  List<double>      => ~InternalChartData~
    - X and Y values are an array, e.g. List<List<double>>         => ~InternalChartData~
    - X values is a List<DateTime>, Y values is a  List<double>    => ~InternalChartData~
- Provide a converter from ~ChartData~ to  ~InternalChartData~


*Current non-Goals of the ~InternalChartData~ class. These may become goals later*
- We can rephrase the simplification of ~double~ (both for X and Y ) in terms of interfaces that allow for *order* and *distance* : let us call them ~OrdinalDimension~ and ~DistancedDimension extends OrdinalDimension~. ~OrdinalDimension~ provides order of it's points,  ~DistancedDimension~ provides distance of it's points. Basically substitute ~double~ everywhere above and is the definition of ~InternalChartData~ with ~OrdinalDimension~ . *BUT I HAVE A TODO HOW TO DO THIS RIGHT*. 
  - ~double DistancedDimension.distance(DimensionPoint point, DimensionPoint point)~ // must satisfy distance properties
  - ~int OrdinalDimension.comparePoints(DimensionPoint point, DimensionPoint point)~
  - ~double DimensionPoint.toDouble()~ - basically, distance from origin on the chart. Required(?) to find a minimum, maximum; We require this for OrdinalDimension as well, where it duplicates order - basically the result is the sequence in a the list of ordered dimension points.


For now all members are public but that may change. Also will describe some constructors later.

#+BEGIN_SRC dart

  /// Used internally as a "data source" by Flutter Charts.
  /// 
  /// Data sources in other formats should provide adaptors to convert to this 
  ///   internal format.  
  /// 
  /// Data Adaptor Examples (just as an overview): 
  ///   - X values is a List<String>, Y values is a  List<double>      => ~InternalChartData~
  ///   - X and Y values are an array, e.g. List<List<double>>         => ~InternalChartData~
  ///   - X values is a List<DateTime>, Y values is a  List<double>    => ~InternalChartData~
  ///   - ~ChartData~                                                  => ~InternalChartData~
  class InternalChartData {

    /// Data defined in terms of the low level primitives - a Dart double.

    List<List<double>> dataRows = new List(); 

    /// Map from x values to xLabel. It's keys and values,
    /// decide whether the X labels displayed are User-Provided or Data-Generated. 
    ///
    /// See the [validateX] method which describes how construction of this map
    ///   affects the labels construction as User-Defined vs. Data-Generated.
    ///
    ///   Below is a summary from [validateX]. This may sound complicated, 
    ///   it exists to *also allow clients
    ///   a simple, no frills way of defining their own X labels directly, 
    ///    similar to the current ~ChartData~ does*.
    ///
    /// 1. Overall Requirement of  [xToXLabelMap]: It is required that [xToXLabelMap]
    ///    contains as many keys as each dataRow length for all [dataRows].
    ///    *Note: If a client does not care about the actual x points, the client must set the keys
    ///        in  [xToXLabelMap] to double 1.0, 2.0 ... etc - as if they were List indexes.*
    ///
    /// 2. Ensure that label is set on all x points, or none.
    ///    So all labels or none must be provided as values of the [xToXLabelMap].
    ///
    /// 3. If labels are not null on all x keys, those labels will be used on the chart -
    ///   so this condition is interpreted as:
    ///   User (Client) provided X labels in [xToXLabelMap],
    ///     and is requesting those labels to be shown, as "User-Defined labels".
    ///
    /// 4. If labels are null on all x keys, this condition is interpreted as:
    ///    User (Client) did not provide labels in [xToXLabelMap],
    ///    and is requesting labels to be "Data-Generated". In this case, the
    ///    formatter [xLabelFormatter] must be provided.

    TreeMap<double, String> xToXLabelMap;
    
    /// Converts a x axis data value to a label representing the value at the x axis point.
    /// Required to create Data-Generated xLabels. 
    ///
    /// See the [validateX] method which describes how construction of this map
    ///   affects the labels construction as User-Defined vs. Data-Generated. 

    String Function(double) xLabelFormatter;


    /// Map from y values to yLabel. **The only purpose of [yToYLabelMap] is to chart Ordinal Y values with User-Defined labels**
    ///
    /// This is similar to [xToXLabelMap] in structure, but the internal use and
    /// assumptions differ.    
    ///
    /// See the [validateY] method which describes how construction of this map
    ///   affects the labels construction as User-Defined vs. Data-Generated.
    /// 
    ///   Below is a summary from [validateY].
    ///
    /// 1. If `yToYLabelMap.length > 0` this condition is interpreted as:
    ///   User (Client) provided Y abels in [yToYLabelMap],
    ///     and is requesting those labels to be shown, as "User-Defined labels".
    ///
    /// 2. Iff `yToYLabelMap.length == 0` , this condition is interpreted as:
    ///    User (Client) did not provide labels in [yToYLabelMap],
    ///    and is requesting labels to be "Data-Generated". In this case, the
    ///    formatter [yLabelFormatter] must be provided.
    ///
    /// 3. Overall Requirement of [yToYLabelMap]: There is no requirement on number of entries 
    ///     in [yToYLabelMap]. 
    ///
    /// 4. If the length of [yToYLabelMap] is not zero, ensure that label is not null on all y points.
    ///
    /// 5. Each entry's value shows one label on the Y axis. 
    ///    
    /// 6. Each entry's key is scaled to the scale of the outer envelope of [dataRows] and set of [yToYLabelMap.keys],
    ///    and the `entry.value` is used as label, on Y position corresponding to the point of `entry.key`
    ///    on the outer envelope.
    ///

    TreeMap<double, String> yToYLabelMap;

    /// Converts a y axis data value to a label representing the value at the y axis point.
    /// Required to create Data-Generated yLabels. 
    ///
    /// See the [validateY] method which describes how construction of this map
    ///   affects the labels construction as User-Defined vs. Data-Generated. 

    String Function(double) yLabelFormatter;


    /// Legends list. Currently has to be set, but can contain empty Strings
    ///  (in which case todo 1 -take that as a hint user does not want the legend section).

    List<String> dataRowsLegends = new List();

    /// Colors list. Currently has to be set. todo 1 - If not set, default to reasonable colors.

    List<ui.Color> dataRowsColors = new List<ui.Color>();


    ////////////////////////// Added also todo 1 **not planning to implement yet** ////////////////////

    /// - If [true], then the x values keep distances in data: For example, if xs = [1,2,20, 200], 
    ///   then the (relative, scaled) distances between [1,2,20, 200], are preserved,
    ///   so that 1,2,20 will be squished on the left. The only chart type where this is allowed
    ///   is the line chart.
    ///   This setting mathematically means that we view the x axis values using
    ///     a proper real value distance as it's distance (in addition to viewing them ordered).
    /// - If [false], then  then the x values will be "equidistanced": For example, if xs = [1,2,20, 200], 
    ///   then the (relative, scaled) distances between [1,2,20, 200], are the same,
    ///   so that 1, 2, 20, 200 will be evently layed out along the x axis.
    ///   This setting mathematically means that we view the x axis values as ordered (ordinal) labels,
    ///     ignoring the distance between them (when taken as numbers)
    ///
    /// A note: X values [xs] are always ~Ordinal~ (ordered). 

    bool keepXValuesDistances
    
  }

  /// Validate the state of values. This code provides a set of rules this object members must satisfy.
  void _validate() {
    _validateX();
    _validateY();
  }

  void _validateX() {

    if (xToXLabelMap == null) {
      throw Error("xToXLabelMap must be defined!");
    }

    for (dataRow in dataRows) {
      if (dataRow.size != xToXLabelMap.size) {
        throw Error("Each Data row must be same size as xToXLabelMap");
      }
    }  
    
    // The setting of either keys or values or both determines the labels construction 
    //   as User-Defined or Data-Generated.
    // The section below describes the options and combinations.
    if (xToXLabelMap.isEmpty()) {
      // no data, return
      return;
    }

    // Overall Requirement of  [xToXLabelMap]: It is required that [xToXLabelMap]
    //    contains as many keys as each dataRow length for all [dataRows].
    // *Note: If client does not care about the actual x points, client must set the keys
    //        in  [xToXLabelMap] to double 1.0, 2.0 ... etc - as if they were List indexes.*
    
    // Ensure that label is set on all x points, or none.
    // So all labels or none must be provided as values of the [xToXLabelMap].
    if (xToXLabelMap.first.value != null) {
      xToXLabelMap.each( (x, labelValue) {
        if (labelValue == null) throw Error(" all labels or none must be provided as values of the [xToXLabelMap]");
      });
    }
    if (xToXLabelMap.first.value == null) {
      xToXLabelMap.each( (x, labelValue) {
        if (labelValue != null) throw Error(" all labels or none must be provided as values of the [xToXLabelMap]");
      });
    }

    // If labels are not null on all x keys, those labels will be used on the chart -
    //   so this condition is interpreted as:
    // User (Client) provided labels in [xToXLabelMap],
    //   and is requesting those labels to be shown, as "User-Defined labels".
    if (xToXLabelMap.first.value != null) {
      // Labels will be User-Defined.
      if (xLabelFormatter is not null) {
        throw Error("xToXLabelMap defines User-Defined labels, xLabelFormatter should not be set");
      }
    }

    // If labels are null on all x keys, this condition is interpreted as:
    //  User (Client) did not provide labels in [xToXLabelMap],
    //   and is requesting labels to be "Data-Generated". In this case, the
    //   formatter [xLabelFormatter] must be provided.
    if (xToXLabelMap.first.value == null) {
      // Labels will be Data-Generated.
      if (xLabelFormatter is null) {
        throw Error("xToXLabelMap does not define User-Defined labels. xLabelFormatter must be set, to create Data-Generated x labels.");
      }
    }
  }

#+END_SRC

Also, although "from a separation of data and view" principle I originally put some of the settings that define the chart "view" onto ChartOptions, I plan to move them to ChartData, and InternalChartData.

- [ ] ChartOptions.useUserProvidedYLabels -> ChartData
- [ ] ChartOptions.yLabelUnits -> ChartData
- [ ] ChartOptions.toLabel(label) -> ChartData
- 

** Refactoring todos

1) [ ] Now we manage rowIndex (seriesIndex) in StackableValuePoint as dataRowIndex. So:
   + Add rowIndex on Presenter (Leaf) as dataRowIndex.

   + [ ] remove rowIndex from everywhere - createPointPresenter (createPresentor) , _createPresentersInColumn - and when it is needed for color, just use the Presenter.dataRowIndex.

2) [ ] Split Function of vertGridLines- *vertGridLines[col].from.dx* serves both to draw grid lines, and ValuePoints. Add, right in XLayouterOutput, a variable for valuePointX - *what is the difference from labelX???*.

3) [ ] Redefine Points and Presenters internal structure, as (from the bottom) double-linked list of points (forms Columns), and double-linked list of Columns (forms PointsColumns = Data) and Presenters (PresentersColumns)

4) [ ] Member privacy issues

   + [ ] ChartPainter.layouter is forced non-private (_) if we want to allow extensibility outside of the chart package (extensibility by clients).
   + [ ] Go over usage of private accessing private _chartLayouter._options - suspect. But maybe ok

5) [ ] Think of a way to get rid of the need to upcast in baseclass using " as SomeClass" - 2 occurences in "presenter as presenters.PointAndLinePresenter"

6) [ ] I think yAxisAbsMin/Max passed to layouters is switched. Fix it

7) *REMOVE NOISE OF nextRightPointsColumn nextRightColumnValuePoint*

   1) [ ] *nextRightPointsColumn* IS LIKELY UNUSED, REMOVE but check.

   2) [ ] *nextRightColumnValuePoint*  IS LIKELY UNUSED, REMOVE but check.

8) [ ] Create a document definiting sequence of layouters, and what each does
   - [ ] particular attention to where scaling happents
9) [ ] *Legend improvements*

   1) [ ] Implement legend as container, with layout that can wrap.

10) [ ] Fix and test formalities, add docs, add examples, resolve versionning and library dependencies and branches, other preps before push to pub
    + [ ] Test and ensure empty data work.
    + [ ] *ADD TESTS FOR RANGE, END TO END ETC*

** Consider Change naming conventions to WX, HY, CY, CX so all names are consistent 
   - whateverOWX (width along x axis    - when context is offset of some other element)
   - whateverOHY (height along y axis   - when context is offset of some other element)
   - whateverCX  (X coordinate  )       - if it is just a point
   - whateverCY  (Y coordinate  )       - if it is just a point
   - rare use below v
   - whateverRWX (width along x axis  - when context is rectangle)
   - whateverRHY (height along y axis  - when context is rectangle)
   - whateverFromCY (Y coordinate from ) - if it is a point which is part of a line
   - whateverToCY (Y coordinate to )     - if it is a point which is part of a line
   - whateverFromCX (Y coordinate from ) - if it is a point which is part of a line
   - whateverToCX (Y coordinate to )     - if it is a point which is part of a line

* Flutter beginner: Experimenting with Flutter using Flutter Charts

This section describes, very briefly with links, how to install Flutter, and the Flutter Charts package.

This section We describe running Flutter Charts in development mode on your device (Android, iOS - follow 1, 2 or 3, 4 and 6), or alternatively on a device emulator (device emulator running from an IDE such as IntelliJ with Android Studio installed - follow 1, 2 or 3, 5, 6 or 7).

1. Install Flutter on your computer. See the installation section on https://flutter.io/.
2. Clone flutter_charts code from Github to your computer. Needs git client.
 
  #+BEGIN_SRC sh
  cd DIRECTORY_OF_CHOICE
  git clone https://github.com/mzimmerm/flutter_charts.git
  # clone will create directory  flutter_charts
  cd flutter_charts
  #+END_SRC

3. (Alternative to 2.): Download and unzip flutter_charts code from Github
   - Browse to  https://github.com/mzimmerm/flutter_charts.git
   - On the righ top, click on the "Clone or Download" button, then select save Zip, save and extract to  DIRECTORY_OF_CHOICE
   - cd flutter_charts
4. Prepare a physical device (must be set to Development Mode "On") to run applications from your computer. Then connect a android device in development mode to your computer. See https://www.kingoapp.com/root-tutorials/how-to-enable-usb-debugging-mode-on-android.htm 

5. (Alternative to 4.): Prepare and start an Android device emulator on your computer.
   - Install Android Studio: see https://developer.android.com/studio/index.html

   - Install an IDE such as IntelliJ with Flutter plugin. See https://flutter.io/intellij-setup/

6. Run Flutter Charts demo app from command line (this will work in both method 4. and method 5.)

   #+BEGIN_SRC sh
   cd DIRECTORY_OF_CHOICE/flutter_charts 
   flutter run example/lib/main.dart 
   #+END_SRC

7. (Alternative to 6.) Run  Flutter Charts demo app from IDE. This will work only with method 5. 
  - Start IntelliJ IDE, create a project in the ~DIRECTORY_OF_CHOICE/flutter_charts~ start an Android emulator, then click on the Run button in Intellij (which should show the ~file:../../../example/lib/main.dart~ in the run button).

* Note : geek charts_flutter use this process and associations between CustomPaint and CustomPainter
geek:
  - ~ChartContainer<D> extends CustomPaint~ = widget that inflates to a custompaint that provides common ChartContext
    - member BaseChart
    - member BaseChartState
  - ~BaseChartState extends State~
    - ~build(buildContext)~ calls and adds child:   _buildChartContainer() which does:
      - chartContainer = new ChartContainer
      - return chartContainer.

From top of example:
- main
- creates State instance
  - in build
    - creates: SimpleBarChart.withSampleData() 
      - returns SimpleBarChart(_createSampleData();
        - where SimpleBarChart extends StatelessWidget
          - has build(context) where it
            - returns charts.BarChart(seriesList); <== so this is called from main
              - BarChart constructor has createCommonChart(BaseChartState) which does
                - return new common.BarChart(params)
                - *passed BaseChartState _buildChartContainer creates new ~ChartContainer which is the CustomPaint~
                - *so this is how far the CustomPaint is created. I create CustomPaint immediately*


- ~ChartContainerCustomPaint extends CustomPainter~ (note the switch)
- ChartContainerRenderObject
  - _setNewPainter creates ChartContainerCustomPaint (painter)
    - called in ChartContainerRenderObject.reconfigure
      - called in ChartContainer.createRenderObject
        - called during mount. ~so Painter is created during mount~


flutter_charts:

- *While FLUTTER CHARTS EXTEND CUSTOM_PAINT, AND HAVE PAINTER (e.g. LineChartPainter extends CustomPainter) AS MEMBER*
  - *PAINTER HAS CONTAINER AS MEMBER*

so I do (-> means association)

LineChart(is CustomPaint) -> LineChartPainter(is CustomPainter) -> Container

This is the same structure as flutter uses!

comparison:

- ~So container ~ painter (while geek : container ~ paint)~
- Also geek has RenderCustomPaint which has nothing to do with CustomPaint, and has CustomPainter on it. Looks like they are re-doing this part of Flutter
- Also geek keeps re-assigning paint's (container's) member painter () different painter (ChildContainerCustomPaint) in _setNewPainter
- So geek can access painter 2 ways:
  - From ChartContainer extends CustomPaint (which has CustomPainter)
  - From RenderCustomPaint which has nothing to do with CustomPaint, and has CustomPainter on it

                      
* IN-PROGRESS-NOW Flutter Charts Enhancements

** DONE Items, bugs, refactorings Implemented
*** DONE Re-implement the layout more generically and clearly. Space saving changes such as /tilting/ labels
*** DONE Labels auto-fit: scale, tilt or skip labels to fit using *HorizontalLabelsContainer*
*** DONE Add integration tests and ability to take screenshot and compare

See https://dev.to/mjablecnik/take-screenshot-during-flutter-integration-tests-435k on how to take screenshots in Flutter

1. Setup integration tests: https://flutter.dev/docs/cookbook/testing/integration/introduction
2. Create an integration test chart_test_1.dart, which will run same code as the app flutter_charts/lib/main.dart 
3. *Must start an AVD device - without this, errors about 'dart:ui' not found!*
4. Command line, run: ~flutter test integration_test/chart_test_1.dart~. Can add -d device.
5. Experiment with ability to run the test. Experiment with clicking on the + button in the test.
6. Replace test_driver/integration_test.dart code with
   #+begin_src dart
     import 'dart:io';
     import 'package:integration_test/integration_test_driver_extended.dart';

     Future<void> main() async {
       try {
         await integrationDriver(
           onScreenshot: (String screenshotName, List<int> screenshotBytes) async {
             final File image = await File('screenshots/$screenshotName.png').create(recursive: true);
             image.writeAsBytesSync(screenshotBytes);
             return true;
           },
         );
       } catch (e) {
         print('Error occured: $e');
       }
     }
   #+end_src
   This adds onScreenshot event handler to integration tests
7. To integration_test/app_test.dart, before all testWidgets where tests are initialized, add this code:
   #+begin_src dart
     final binding = IntegrationTestWidgetsFlutterBinding();
     IntegrationTestWidgetsFlutterBinding.ensureInitialized();
   #+end_src
8. To the code of the test, at the point you want to take the screenshot, add this code
   #+begin_src dart
     await binding.takeScreenshot('test-screenshot');
   #+end_src
** LATER Enhancements in progress or planned - priority order

*** Create a document / image showing chart layout and spacing - show option variables on image
Also:
- document applyParentOffset and pull from Container?
- go over Container and document

*** Add org mode based integration build, which allows to run and test all "known/predefined" code scenarios that work. 
*** To the above org mode base integration build, add ability to "capture self", and compare result as jpeg/svg with known jpeg/svg results
*** Add formatter for YLabels.
*** Option additions that control look:
**** Add options to hide the grid (keep axes)
**** Add options to hide  axes (if axes not shown, labels should not show?)
**** Decrease option for default spacing around the Y axis.
*** Provide tooltip support
*** Provide a few more chart types: Spline line chart (stacked line chart), Grouped VerticalBar chart,
.
*** Data types
**** Independent (X value) data types
***** There should be adapters from any dependent (X value) data types:
****** Ordinal - x values spaced evenly, only sequence matters
****** Measured - x values are convertible to numbers
******* Date types
******* Number types
******* Others?
**** Dependent (Y value) data types - for now, keep double, can provide converters.

*** For ChartOptions.useUserProvidedYLabels = true. See example with User defined YLabels: Current implementation sets the minimum of dataRows range (1.0 in the example) on the level of the first Y Label ("Ok" in this example), and the maximum  of dataRows range (10.0 in this example) on the level of the last Y Label ("High" in this example). This is not desirable, we need to add a userProvidedYLabelsBoundaryMin/Max.
*** Next, add ability to invert X and Y axis (values on horizontal axis)
*** TextPainter notes

If layout() is called, following paint() always prints full line  (goes to line 2 if the text contains LF).

** IN-PROGRESS Refactorings to make flutter_charts a bit like Morphic (marginally like it)

*** DONE Move all painting from ChartPainter.paint to ChartContainer.paint

*** DONE ~Remove _paintYLabels and similar~, just replace with content of the method.

*** IN-PROGRESS ~LayoutExpansion: Refactor LayoutExpansion to SizeConstraint and clarify role of SizeConstraint~
**** DONE Study function of LayoutExpansion and remove the GrowDoNotFill, TryFill, definition, parameters, arguments, and passing down entirely.

- LayoutExpansion is actually a fake - it in facts holds on to the Container size before and after layout. Eventually, convert it to "layoutSize" field instead of the getter.

**** DONE LayoutExpansion: more study and cleanup - pass to layout instead of to Container constructor (required layoutExpansion)

I suspect, this is actually used as Container.preLayoutSize - sort of like preferredSize !!!!
- or maybe as layoutSize member that is settable, to bypass only getter getLayoutSize
  
Study it and comment, maybe rename and refactor.

Code review:

- [ ] Container._layouExpansion is ONLY set during construction, so should be doable to be final! 
- [ ] LayoutExpansion is now passed to layout as it functions basically as SizeConstraint!!
-


**** DONE LayoutExpansion and Containers: remove all _layoutSize from extensions of Container, and add it as member to Container, replacing getter layoutSize in preparation of moving all these basic elements related to layout to Container.

This should be possible, and in principle relatively simple .. well it still has some leftover work below.

- [X] Remove _layoutSize from specializations of Container
- [X] Remove get layoutSize from specializations of Container 
- [X] Container layoutSize will need set and get. To set, add new private _debugLayoutSetCount. This will be interesting to know if the setter was called after initial set in layout
- [X] Make sure _layoutSize is only in Container. Outside Container, use layoutSize 


**** DONE Consider if LabelContainer needs to call layout again: places like: yLabelContainer.layout(LayoutExpansion.unused());

Not needed, commented out and tested.

**** DONE LayoutExpansion and Containers: remove all _layoutExpansion from extensions of Container AND Container. ~layoutExpansion is passed to layout, but NOT held on~

**** DONE Put back grid on the line chart.

- why did it disappear?

  Reason: In LineChartDataContainer

  #+begin_src javascript

  void paint(ui.Canvas canvas) {
    _paintGridLines(canvas);
    _drawDataPresentersColumns(canvas);
  }

  #+end_src

  The _paintGridLines was missing
**** DONE NO, KEEP chartArea for now : Review use of chartArea on ChartContainer, see if it should be simply replaced with layoutSize !!!

- but express that ChartContainer layoutSize should never change, be fine
**** DONE ~LayoutExpansion and Containers: Now when the layoutSize is holding the passed layoutExpansion, Remove from Container, all members and getters for layoutExpansion.~

Ok, now Nothing holds on layoutExpansion. Only passed to layout(layoutExpansion)

Note: We can add at most a getter later (Flutter RenderObject and RenderBox has get constraints)

**** DONE Move Container.dart to it's own package containter_base.dart

- This was easy, only had to make isDistressed public.

**** IN-PROGRESS Rename LayoutExpansion to BoxSizeConstraint (SizeConstraint equivalent of BoxConstraints to distinguish from BoxConstraints)

- LayoutExpansion
  - make members final
  - test
  - add min/max and getter for width,height as in BoxConstraints
  - test
  - add tight and similar constructors as in BoxConstraints.
  - test 
  - Rename (substitution? Refactor?) to BoxSizeConstraint, also variables.
    

**** TODO Rename ~offset to layoutOffset~ and rename ~applyParentOffset to applyParentLayoutOffset~

**** TODO ~Core Problem - we are creating new Containers inside layout: We are creating legendItems in legendItemContainer.layout~

This is a core design issue. Think about this and review. This may not be salvageable.

Thoughts:

- Maybe the lifecycle needs to be:
  - setup() - Create top Container and Children - all of them, for example, all labels 
  - layout() - Layout Container and children. If there is not enough space, delete some containers created during setup(), or skip them in layout  
  - paint() - Paint the layed out Containers, skipping those marked to skip

**** TODO ~LineContainer: Call layout as called on other containters, rather than rely on this.lineFrom and this.lineTo being changed in the constructor!!~

- This is related to the fact that LineContainer.paint is just painting the  this.lineFrom and this.lineTo, so no layout is needed
  
**** TODO Look into remaining usages of "ui.Size get layoutSize"


*** TODO ~In Container, provide a default paint() method rather than abstract, like this~

#+begin_src javascript

  void paint(ui.Canvas canvas) {
    for (var yLabelContainer in _yLabelContainers) {
      yLabelContainer.paint(canvas);
    }
  }

#+end_src
*** TODO Make Containers a hierarchy - Everything is a container. Layout, Inset, etc are also containers. Containers are wrapped and only contain children, not layouts, or other loose containers.
**** TODO Add return Size to layout. This should return current Container.layoutSize . This is for the short term.
**** TODO Edit all calls to layout and return it

**** TODO ~Add SizeConstraint~

                                     
- [ ] Add size_constraint.dart -
  - SizeConstraint{ _maxSize = Size.infinity; SizeConstraint({maxSize:}); SizeConstraint.infinity: redirect to SizeConstraint(maxSize: Size.infinity};},
- [ ] In existing code, Pass SizeConstraint to each Container.layout({required SizeConstraint sizeConstraint})
- [ ] Add SizeConstraint field to Container, from constructor.


**** TODO ~Container class~ - make it a hierarchy:

Container is it's children, but it can rotate or be moved.

***** TODO Add members and methods to Container class

- [ ] Add hierarchy stuff
  - [ ] ~parent~ [on top member it should be Contaier.root (in ChartContainer)]
  - [ ] ~children~ should be just a List<Containers>
  - [ ] ~traverse()~ 
  - [ ] ~flatten()~ 
  - [ ] ~isUniqueName()~
  - [ ] ~isRoot()~
- [ ] Add Content management stuff
  - [ ] ~addChild(Container)~ - can never be root
  - [ ] ~name~ not null, required
- [ ] Add Constructors
  - [ ] ~Container.root~, configure as root
    - member ~name~ set in all constructors or defaults to random string, functions as unique key. later Ensure name unique in hierarchy. 
  - [ ] constructor from children by passing children: List<Container>
- [ ] Layout related stuff
  - [ ] add member ~sizeConstraint~ - NOT NOW, LATER - ONLY PASSED TO LAYOUT, NO NEED TO HOLD ON TO - But flutter holds on to constraints in RenderObject 
  - [ ] add member ~layoutSize~
  - [ ] keep member ~layoutOffset~
  - [ ] implement default method ~layout(SizeConstraint)~ - see [[Layouter general function]]
  - [ ] add abstract method ~calculateAndSetActualChildrenLayoutSizesAndOffsetsInSelf()~ # Calculates children's positions in self based on what the layout actually is
  - [ ] ~applyParentOffset~ removed (BUT KEEP AT FIRST) - replaced by calculateAndSetActualChildrenLayoutSizesAndOffsetsInSelf
    - applies offset on self (call super)

***** TODO How do we want the Containers function eventually?

- Generally, Containers lifecycle should be as follows.
  - Create Container Hierarchy. This is specific, but for Chart, we should just add containers we know od
    - create Root (ChartContainer)
    - add all children recursively 
  - Layout
    - called by root.layout(SizeConstraint)
    - side effects
      - set layoutSize on all members in hierarchy (currently not done)
      - set offset (applyParentOffset) on all members in hierarchy 
  - Paint 
  
*** TODO ~HUGE - establish hierarchy between current Containers children of ChartContainer~ 
*** TODO ~Convert ChartContainer.layout to use the new concepts - CONVERT ONLY ON THIS LEVEL, NOT CHILDREN~
**** TODO Move some code to calculateAndSetActualChildrenLayoutSizesAndOffsetsInSelf

Code between layout and applyParentOffset, like this:
#+begin_example
    xContainer.layout();

    ui.Size xContainerSize = xContainer.layoutSize;
    ui.Offset xContainerOffset = new ui.Offset(
        yContainerSize.width, chartArea.height - xContainerSize.height);
    xContainer.applyParentOffset(xContainerOffset);
#+end_example
shoudl be moved to a XContainerManualLayout(new layout class).calculateAndSetActualChildrenLayoutSizesAndOffsetsInSelf
**** TODO What else  - much more

*** TODO ~HUGE - establish hierarchy between rest of current Containers~ (NOT non-container classes like Presenters, PresentersColumn etc)

*** TODO ~Convert all Presenter, PointsColumn, PointsColumns etc  to Containers but keep the code structure the same~
**** IN-PROGRESS ~Note: HIERARCHY OF CONTAINERS~
- ~ChartContainer~
  - ~PointsColumns~ pointsColumns; // NOT a container  - created from DataRows.
  - ~LegendContainer~ extends ChartAreaContainer 
    - has List<LegendItemContainer> _legendItemContainers  // is container, checked all the way down
  - ~YContainer~
    - has List<AxisLabelContainer> _yLabelContainers; // is container, checked all the way down
  - ~XContainer~ 
    - has List<AxisLabelContainer> _xLabelContainers; // is container, checked all the way down
  - ~DataContainer~
    - has GridLinesContainer _xGridLinesContainer; // is container, checked all the way down
    - has GridLinesContainer _yGridLinesContainer; // is container, checked all the way down
    - has PresentersColumns presentersColumns (is List<PresentersColumn>; // NOT a container
      - PresentersColumns // NOT a container
        - During constructions, calls self(CustomList).add(PresentersColumn)
      - PresentersColumn  //  NOT a container 
        - List<Presenter> presenters;
        - During construction, calls ~_createPresentersInColumn~
          - accepts:
            - PointsColumn // END. NOT a container
              - has List<StackableValuePoint> points;
            - OR
            - List<StackableValuePoint> fromPoints,
          - ~creates the VerticalBarPresenter and LineAndHotspotPresenter from one StackableValuePoint~: 
          - [ ]
**** TODO ~TO CONTAINERS CONVERSION~
- [ ] All classes that are currently "container like" (extend ListBase) but do not extend Container, extend from Container. Must add 
  - [ ] First experiment on ~PresentersColumns~
- [ ] Find where Presenters get their internal values set
  - They are set in constructors, which are created during layout() of parents
  - For example, VerticalBarPresener constructor, all values (that is offsets) are established in Contructory, NOT in layout!
- [ ] Replace the above sites with calls to layout(maxSize: internal values from existing code);
- [ ] Convert to Containers
  - [ ] ~Presenter - VerticalBarPresenter, LineAndHotspotPresenter~
    - At which point does presenter gets size? ~when Presenter is created, it is passed StackableValuePoint, which contains the sizes~
    - VerticalBarPresenter({required StackableValuePoint point,
      - presentedRect = new ui.Rect.fromPoints(barLeftTop, barRightBottom); // so this is where the size is set!!!
    - LineAndHotspotpresenter
      - LineAndHotspotPresenter({  required StackableValuePoint point,
      - toPoint ??= fromPoint;
      - lineContainer = new LineContainer(
        lineFrom: fromPoint,
        lineTo: toPoint,
        linePaint: rowDataPaint..strokeWidth = options.lineStrokeWidth);
      - offsetPoint = fromPoint; // point is the left (from) end of the line
      - innerPaint = options.hotspotInnerPaint;
      - outerPaint = options.hotspotOuterPaint;
      - innerRadius = options.hotspotInnerRadius;
      - outerRadius = options.hotspotOuterRadius;
  - ~LineContainer (passed and living in LineAndHotspotPresenter) already extends Container!!~
    - class LineContainer extends flutter_charts_container.Container
  - ~ALL DRAWING ON CANVAS ARE ALREADY IN cONTAINERS. BUT THERE ARE OTHER OBJECTS IN BETWEEEN THOSE PAINTING CONTAINERS, ARE THOSE IN-BETWEEN ARE NOT CONTAINERS. WE HAVE TO CONVERT IN-BETWEEN TO CONTAINERS AS WELL~
    - ~The problem is, the presenters do not "paint/draw" themselves, but are drawn in parents~
      - ~VerticalBarChartDataContainer._drawDataPresentersColumns~
    - ~BUT WHERE ARE THE POSITIONS OF THE PRESENTORS INSIDES CALCULATED??~
      - ~CALCULATED IN ChartContainer.layout -> DataContainer.applyParentOffset -> DataContainer.setupPresentersColumns -> new PresentersColumns(pointsColumns: parentContainer.pointsColumns,~ 
      - So the calculation and drawing both happens in parents, NOT presenters.
 
- [ ] ~CONVERT THE IN-BETWEENS TO CONTAINERS, AND ITERATE THE layout and paint calls~
  - [ ] PointsColumn
  - [ ] PointsColumns
  - [ ] NOT StackableValuePoint
  - [ ] May need a special extension of Containers for some of the above.
  - [ ] Anne Kilpatrick
    - 43 M valuation, 146 Units 
    - Oakville 10 M dollars / acre at lake
    - here it is 7M / acre =>  164 - this would be $475 / unit ????
    - 
  - 
**** TODO Rename Container.paint to Container.presentOn - we may need
**** TODO research which containers hold on parents and children
**** TODO Make containers a hierarchy
***** Add 'parent' and 'children' members
***** Add 'name' member to Container 
**** TODO Ensure code sets up the hierarchy correctly 
***** Study use of GridLinesContainer, XContainer etc, their membership 
**** TODO Put ChartOptions only on top Container (ChartContainer, may be there already
***** remove passing the ChartOptions down
***** access ChartOptions in Containers via the (get)root 
***** 
*** TODO Remove complexity around passing ChartOptions.
*** TODO ChartContainer: Keep the class, but convert to Container where possible in method arguments.

***** I think in most places, we use ChartContainer  ONLY to pass down ChartOptions. So analyze such uses and convert to Container where possible, and get Options via root.chartOptions.
*** TODO Study Morphs what else needs added!
*** TODO Rename Container into Morph
**** Add a list of children to Morph
**** Add name field to Morph 
** IN-PROGRESS-NOW Add logarithmic scale. 
*** NOTE Doc: YLabels, YScaler, and their layout in flutter_charts

ChartData yLabels and dataRowsColors behave differently.

reason is, yLabels have 2 modes:
- When yLabels passed to constructor, then they are set to non-null in argument, then manual layout is used.
- When yLabels not passed, they are not used at all! Instead an auto layout of Y is used as follows:
  - yScaler.labelInfos is used instead
    - yScaler is created from this code
      #+begin_src dart
        YScalerAndLabelFormatter _layoutCreateYScalerFromPointsColumnsData(double yAxisMin, double yAxisMax) {
          List<double> flatData =
          geometry.iterableNumToDouble(_chartTopContainer.pointsColumns.flattenPointsValues()).toList(growable: true);

          Range range = Range(
            values: flatData,
            chartOptions: _chartTopContainer.options,
          );

          // revert toScaleMin/Max to accommodate y axis starting from top
          YScalerAndLabelFormatter yScaler = range.makeLabelsFromDataOnScale(
            toScaleMin: yAxisMin,
            toScaleMax: yAxisMax,
          );
          return yScaler;
        }

        ///////////////
        YScalerAndLabelFormatter makeLabelsFromDataOnScale({
            required double toScaleMin,
            required double toScaleMax,
        }) {
          double min = _closure.min;
          double max = _closure.max;

          Poly polyMin = Poly(from: min);
          Poly polyMax = Poly(from: max);

          int signMin = polyMin.signum;
          int signMax = polyMax.signum;

          // envelope for all y values
          double from, to;

          // Need to handle all combinations of the above (a < b < c etc).
          // There are not that many, because pMin <= pMax and pDiff <= pMax.
          /* keep
          if (false && powerDiff < powerMin) {
          // todo-00-github-issue-31 : Allow start Y axis from non-zero
          // todo 1 - enable conditions where y=0 axis is not needed to show,
          //          to allow for details, mainly for lots of values.
          //          Make an option for this. Add to tests.
          from = polyMin.floorAtMaxPower.toDouble();
          to = polyMax.ceilAtMaxPower.toDouble();
        } else {
          ,*/
          // for now, always start with min or 0, and end at max (reverse if both negative).

          if (signMax <= 0 && signMin <= 0 || signMax >= 0 && signMin >= 0) {
            // both negative or positive
            if (signMax <= 0) {
              from = min;
              to = 0.0;
            } else {
              from = 0.0;
              to = max;
            }
          } else {
            from = min;
            to = max;
          }
          // keep }

          // Now make labels, evenly distributed in the from, to range.
          // Make labels only in polyMax steps (e.g. 100, 200 - not 100, 110 .. 200).
          // Labels are (obviously) unscaled, that is, on the scale of data,
          // not the displayed pixels scale.

          List<double> labels = _distributeLabelsIn(Interval(from, to)); // todo 0 pull only once (see below)

          // print( " ################ makeLabelsFromData: For ###_values=$_values found ###labeValues=${labels} and ###dataRange= ${from} to ${to} ");

          var yScaler = YScalerAndLabelFormatter(
            dataRange: Interval(from, to),
            valueOnLabels: labels,
            toScaleMin: toScaleMin,
            toScaleMax: toScaleMax,
            chartOptions: _options);

          yScaler.scaleLabelInfos();
          yScaler.makeLabelsPresentable();

          return yScaler;
        }


        List<double> _distributeLabelsIn(Interval interval) {
          Poly polyMin = Poly(from: interval.min);
          Poly polyMax = Poly(from: interval.max);

          int powerMax = polyMax.maxPower;
          int coeffMax = polyMax.coefficientAtMaxPower;
          int signMax = polyMax.signum;

          // using Min makes sense if one or both (min, max) are negative
          int powerMin = polyMin.maxPower;
          int coeffMin = polyMin.coefficientAtMaxPower;
          int signMin = polyMin.signum;

          List<double> labels = [];
          int power = math.max(powerMin, powerMax);

          // todo-1 refactor this and make generic
          if (signMax <= 0 && signMin <= 0 || signMax >= 0 && signMin >= 0) {
            // both negative or positive
            if (signMax <= 0) {
              for (double l = 1.0 * signMin * coeffMin; l <= 0; l++) {
                labels.add(l * math.pow(10, power));
              }
            } else {
              // signMax >= 0
              for (double l = 1.0 * 0; l <= signMax * coeffMax; l++) {
                labels.add(l * math.pow(10, power));
              }
            }
          } else {
            // min is negative, max is positive - need added logic
            if (powerMax == powerMin) {
              for (double l = 1.0 * signMin * coeffMin; l <= signMax * coeffMax; l++) {
                labels.add(l * math.pow(10, power));
              }
            } else if (powerMax < powerMin) {
              for (double l = 1.0 * signMin * coeffMin; l <= 1; l++) {
                // just one over 0
                labels.add(l * math.pow(10, power));
              }
            } else if (powerMax > powerMin) {
              for (double l = 1.0 * signMin * 1; l <= signMax * coeffMax; l++) {
                // just one under 0
                labels.add(l * math.pow(10, power));
              }
            } else {
              throw Exception('Unexpected power: $powerMin, $powerMax ');
            }
          }

          return labels;
        }

      #+end_src
    - yScaler notes  
      so the labels are created in "distributeLabelsIn(Interval)"
      - Interval is DATA interval - *a simple min/max value on data* (more precisely interval from ~_chartTopContainer.pointsColumns.flattenPointsValues()~ which on bar chart is added data)
      - *so the labels are simple distribution of as many labels as needed between data min/max - ChartData.yLabels are NEVER USED when not set in constructor.*

        *todo*:
        - rename _closure to _envelope
        - rename value in params in range to pointsColumnsPointsValues
        - Add test that is like RandomData but with similar real data.
*** NOTE Doc: ChartData flow in the system, data values and names, where are labels created from values 
1. ~ChartTopContainer.layout~
   - ~ChartTopContainer.setupPointsColumns~
     - ~PointsColumns~ costructor (passed TopContainer with data). Internally, this done in ~PointsColumns._createStackableValuePointsFromChartData~. In the end, *transformed data* lives in ~PointsColumns.each.PointsColumn.stackableValuePoints.each.StackableValuePoint.dataY~.
     - Result: each ~transformed~ data point from ~ChartData.dataRows is converted ==> StackableValuePoint~
2. ~YContainer.layout~
   - ~YContainer.layoutAutomatically~
     - ~YContainer._layoutCreateYScalerFromPointsColumnsData(axisYMin, axisYMax~
       - ~allStackedDataYs = _chartTopContainer.pointsColumns.flattenPointsValues()~
       - ~new Range(values: allStackedDataYs, options)~
       - ~yScaler = Range.makeYScalerWithLabelInfosFromDataYsOnScale(axisYMin: axisYMin, axisYMax: axisYMax,)~
         - This creates the disctributed labels as follows:
           - ~distributedLabels = Range.distributeLabelsIn(Interval(dataYsMinExtendedTo0, dataYsMaxExtendedTo0,))~
             - So the labels are distributed in the TRANSFORMED dataYMin, dataYMax (maybe extended)
           - ~yScaler = YScalerAndLabelFormatter(dataYsEnvelop: Interval(dataYsMinExtendedTo0, dataYsMaxExtendedTo0), labelYsInDataYsEnvelope: distributedLabels, axisYMin: axisYMin, axisYMax: axisYMax, chartOptions: _options);~
         - In the end, the ~yScaler~ scales from the (extended) dataYMin - dataYMax to the axisYMin - axisYMax. So, given a label's raw value, it will display the raw value, which is what we want.

*** DONE Add unit tests for the following unclean classes and methods, before refactoring them
- [X] util_dart.scaleValue  
- [X] Range.makeYScalerWithLabelInfosFromDataYsOnScale # This includes  Range.distributeLabelsIn(Interval)
- [ ] YScaler.scaleLabelInfos later
- [ ] YScaler.makeLabelsPresentable later

*** IN-PROGRESS-NOW Logarithmic Y scale
**** DONE Rename ownScale to yValueScale, toScale to toDisplayScale
**** DONE *Logarithmic scale, with existing formatters and label creators*
***** DONE Bug fix: Ex40 which is manual scale is now using logarithmic scale. Fix it.

Fix: During manual layout, LabelInfo.transformedDataValue was not set.

***** DONE Logarithms of base 10 and e
loge(10) = ln10 <==> e^ln10 = 10
loge(x) = y <==> e^y = x
log10(x) = y <==> 10^y = x <==> (e^ln10)^y = x <==> e^(ln10*y) = x <==>  ln10*y = lne(x) <==> y = lne(x) / ln10

So

log10(x) = y # substiture above for y

log10(x) = lne(x) / ln10 - where ln10 is loge(10)

~So in Dart speak~, where lne = log:

~log10(x) = log(x) / ln10~ where log(x) is loge(x) and ln10 is loge(10)

Or - with making a more math notation

log10(x) = loge(x) / loge(10)

e^loge(x) = x ; e^loge(10) = 10

***** DONE Steps to introduce logarithmic scale
 
- [X] Add data test if scale is logarithmic: only allowed if yValues are numeric and >= 0, otherwise exception, method: checkDomainAndRangeValidFor(yTransform)  
- [X] ! The above needs ChartData to contain ChartOptions. So this requires API deep changes. ChartOptions is passed to ChartData rather than ChartTopContainer such as VerticalBarChartTopContainer
- [X] NOT FOR NOW: If scale is logarithmic, enforce the setting data starts above 0
- [X] Add comments:
  - [X] LabelInfo.dataValue should ONLY be used for labels, never for data or coordinates
  - [X] *Data displayed inside the chart use transformed data values, displayed labels show raw data values*
  - [X] On  axisYMin than it is really axisYBottom (which is on the bottom of the chart, but has the max value). Similar to Max
**** DONE Rename distributedLabels to distributedLabelYs
**** DONE Rename yLabelsDividedInYAxisRange  to manuallyDistributedLabelYs
**** IN-PROGRESS-NOW Manual vs Automated layout changes

- [ ] Manual layout does not use Range. Make it use Range and work semantically same as manual layout:
  #+begin_src dart
    Range range = Range(
      values: allStackedDataYs,
      chartOptions: _chartTopContainer.options,
    );

    // revert axisYMin/Max to accommodate y axis starting from top
    YScalerAndLabelFormatter yScaler = range.makeYScalerWithLabelInfosFromDataYsOnScale(
      axisYMin: axisYMin,
      axisYMax: axisYMax,
    );
  #+end_src
- [X] Remove Range and pull it's functionality to YScalerAndLabelFormatter
- [X] Range only manages a list of values, that represents labels anyway! Do this:
  - [X] Move the 2 members from Range to YScalerAndLabelFormatter
  - [X] Move Range.makeYScalerWithLabelInfosFromDataYsOnScale to YScalerAndLabelFormatter private method, called from it's constructor
  - [X] Remove Range
  - [X] Fix tests and test
- [ ] Manual Layout
  - [ ] use terminology userLabelsDrivenLayout instead of manualLayout
  - [ ] Find code commonalities between userLabelsDrivenLayout and autoLabelsDrivenLayout
  - [ ] 
  - [ ] Fix manual layout to work the same as auto layout
  - [ ] Remove !. in code if possible
  - [ ] Test
  - [ ] push
  - [ ] remove UNUSED methods
  - [ ] Make YScaler members and methods private
  - [ ] Remove YScaler member dataYsEnvelop
  - [ ] remove obsolete comments
  - [ ] ~Add note to appropriate place that dataYs once out of ChartData are always transformed, then stacked, then potentially scaled !! This is the sequence that always happens. Transform may be identity~
  - [ ] 
  - [ ] 
**** TODO Refactor ChartOptions

- [ ] Rename in place ChartOptions to CommonChartOptions 
- [ ] pull loose LineChartOptions members to a LineChartOptions 
- [ ] convert VerticalBarChartOptions to empty class
- [ ] Change ChartOptions to extend BaseChartOptions, and add 2 members,  LineChartOptions, VerticalBarChartOptions
- [ ] Remove any references in code to LineChartOptions, VerticalBarChartOptions.
- [ ] Make code and test work.
**** TODO Rename any Envelop to Interval
**** TODO Rename any _container, container members to _topContainer if it is actually ChartableTopContainer
**** TODO TODO: Rename DataRows to RawDataRows, DataRow to RawDataRow.

*We only use dataRows and dataYs which represent transformed data, so make it consistent*
- [ ] Rename DataRows and related to RawDataRows
- [ ] Rename DataRow to RawDataRow.
- [ ] Rename LabelInfo.dataValue -> LabelInfo.rawDataValue
- [ ] Rename LabelInfo.transformedDataValue to dataValue
- [ ] In the end, 'data', 'dataY' represents transformed. 'rawData' 'rawDataY' represents original data.
- [ ] This is nice because 'data' is short, and most of the codes deals with 'transformed data', named 'data', which is short . Places in code where we see 'rawData' are not-transformed original data.
**** TODO LabelInfo: Make some parts a getter rather than member

- [ ] Convert LabelInfo.rawDataValue to getter
- [ ] Convert LabelInfo.axisValue to getter

**** TODO Change AdjustableLabelsChartAreaContainer to a MIXIN.

AdjustableLabelsChartAreaContainer is just a marking class to hold _labelLayoutStrategy. We should not be adding class on the hierarchy to only hold some data - those should be mixins. Note: the only extension is XContainer

**** TODO Refactor StackableValuePoint nextRightColumnValuePoint

The StackableValuePoint maintains a link to predecessor, via it's ~predecessorPoint~ member.
However, there is also a need (only in LineAndHotspotPresenter) to maintain a link to successor.
This successor is named ~nextRightColumnValuePoint~, set in _createStackableValuePointsFromChartData using ~nextRightPointsColumn~, and passed around so much.

~Can we remove the nextRightColumnValuePoint everywhere, and place it on StackableValuePoint as successorPoint?~
Then we could also remove all the passing around of ~nextRightColumnValuePoint~.

  LineAndHotspotPresenter({
    required StackableValuePoint point,
    StackableValuePoint? nextRightColumnValuePoint,

**** TODO Move construction of XContainer, YContainer and others from the ChartTopContainer.layout() method to ChartTopContainer constructors. This may be questionable!! *THINK First*
**** TODO Address todo-00-later 
**** TODO Bug Vertical Bar log Y axis (Ex 52): The number showing is 10,000,000,000 - 10,000 times more than it should

IN STACKED CHART, WE FIRST PASS LOG(Y), THEN ADD LOG(YS) DURING STACKING. THAT IS WRONG. THE STACKABLE COLUMNS MUST FIRS ACCEPT un-transformed, THEN ADD DURING STACKING, THEN DO transform (LOG). An alternative is to un-transform, then add, then re-transform. Third alternative is to store on StackableValuePoint both rawData as well as Data.


** TODO ChartData further refactoring. Add DataSetsMixin, and add DataPoint, more representing oo behavior

*** TODO Question any place in the library importing import 'package:flutter_charts/flutter_charts.dart'; and change to import only needed sources.
*** TODO ChartData will contains DataSetsMixin contains DataPoints which is custom List<DataPoint>
*** TODO So we need new class DataSet;   DataSets is custom List of DataSet.
*** TODO So we need new class DataPoint; DataPoints is custom List<DataPoint>
*** TODO DataPoint can be any object - sort of a naked user object
*** TODO DataSetsMixin corresponds to dataRows
*** TODO DataPoints corresponds to one dataRow.
*** TODO DataSetsMixin is a mixin which provides functions that allow to extract values from DataPoint, for example
**** DataSetsMixin.xValue(DataPoint, pointIndexInSets) =>  whatever value at DataPoint is considered x // similar for Y
**** DataSetsMixinMixin provides ~default functions which extract xLabel, yLabel, yTransform~
***** DataSetsMixin.xLabel(DataPoint, pointIndexInSets) => DataSetsMixin.xValue(DataPoint, pointIndexInSets) // similar for Y
***** DataSetsMixin.yTransform

*** TODO ~DataSetsMixin must be extended as MyDataSetsMixin, implementing at least 2 methods: xValue and yValue, see aboce~
*** TODO What options are controlled on the ChartData level? What on the DataSetsMixin level?
*** TODO ~???? Move ChartOptions to ChartData ??? Or some other redesign using configurations ???~
**** TODO ~Move function _options.yContainerOptions.valueToLabel to function ChartData.yLabelFormatter and allow to pass it and store as member~
****** TODO This is the first crack on removing ChartOptions completely and move it to ChartData
****** TODO ~ChartData must be passed to Range, along with options, to make the transforms available~
**** TODO Similar to above, ~Move function ChartOptions.YContainer.yTransform to ChartData and allow to pass it and store as member. Defaults to identity~ 
**** TODO ~Finish moving ChartOptions entirely to ChartData
*** TODO Replace y label formatter and scaler with a more elegant, see pilot project - I added one there. See todo-00-last-last
*** TODO If line chart, add option that allows to start on non-zero
    - add option userProvidedYLabelsBoundaryMin OR startYLabelsOnMinimumDataValues.
    - test  on values like 10,000 - 11,000.
    -
*** TODO Allow to create multiple charts (combined chart) in one graph - for example, line and bar chart in one graph, on same or different Yaxis (and labels), same or different xAxis (and labels).
This needs entity model change:
- current ChartData and ChartOptions are kept on ChartTopContainer
- current data structure is as follows: ChartData -> DataSetsMixin -> DataPoints - unchanged
- currently ChartOptions is set on Painter along with ChartData;  available from any Container by reaching to parentContainer or topContainer
- need to allow/add member ChartOptions on DataSet (default still on the ChartTopContainer, placed there from Painter)
- need to allow/add member presentAs on DataSet (presentAs line chart or bar chart) 
- need to allow xLabels and yLabels on DataSet ?? How ??
- we allow to set both options AND enum chartType on ChartDataRows
- we add CombinedChart (in addition to LineChart and VerticalBarChart) - CombinedChart must allow to set  
Now this presents a problem as to API: Now we are not creating LineChart, or VerticalBarChart, but a Chart WITH LineChart and VerticalBarChart in it. SO MAYBE THE DISTINCTION BETWEEN LINE AND BAR IS ON THE
** TODO *todo-00-soon* add function which applies to Y data and scale but not labels. Use for logarighmic examples.
