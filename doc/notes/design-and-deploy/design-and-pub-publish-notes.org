#+OPTIONS: toc:3
#+TODO: TODO TODO-NEXT IN-PROGRESS IN-PROGRESS-NOW LATER HOLD DONE-THIS-ITERATION DONE NOTE


* TODO Bugs and issues - flutter_charts
** TODO The stock charts example contains a bug which reverts the series on the negative values - both negative dataRows, and dataRowsColors must be reverted for the chart stacks to show in intended order (black, green grey red from top). But even then, dataRowsLegends are incorrect. 
 
** TODO Bug Vertical Bar log Y axis (Ex 52): The number showing is 10,000,000,000 - 10,000 times more than it should

IN STACKED CHART, WE FIRST PASS LOG(Y), THEN ADD LOG(YS) DURING STACKING. THAT IS WRONG. THE STACKABLE COLUMNS MUST FIRS ACCEPT un-transformed, THEN ADD DURING STACKING, THEN DO transform (LOG). An alternative is to un-transform, then add, then re-transform. Third alternative is to store on StackableValuePoint both rawData as well as Data.

** TODO On Feb 5, 2022, all of the sudden, with no changes a new issue appeared: Error: No named parameter with the name 'displayLarge'.

Details: When running

~flutter test test/widget_test.dart~

new error
*Error: No named parameter with the name 'displayLarge'.*

This is an annoying newly introduced bug by Google fonts presence. OMG this is bad.

A workaround is here:

https://stackoverflow.com/questions/70997381/flutter-error-no-named-parameter-with-the-name-displaylarge

bug core is here:

https://github.com/material-foundation/google-fonts-flutter/issues/219

* NOTE *Pub - Publish flutter_charts* : Workflow of publishing new version on flutter_charts on https://pub.dartlang.org
** ~dart pub outdated --no-dev-dependencies --up-to-date --no-dependency-overrides~
Run this to resolve a warning on pub.dev about "transitive dependencies".

When run, some packages may show starting with * as redish, for example:

PACKAGE   *1.8.0   1.8.1       1.8.1       1.8.1    

If they do and are DIRECT DEPENDENCIES, run on those packages:

~dart pub upgrade --major-versions PACKAGE~

If the * are not direct dependencies, no action needed.

(For example, I had to do:

~dart pub upgrade --major-versions decimal~
To upgrade decimal to latest version, so that pub.dev does not complain about "transitive dependencies". Not sure how to do this for all?

** ~flutter pub upgrade; flutter pub get~
Upgrades packages listed in ~pubspec.yaml~ to the highest version listed (and also available on pub) 
** Test ~tool/test/run_all_tests.sh~ - details below

Run ~d1=$(date +%s); flutter clean; flutter pub upgrade; flutter pub get; tool/test/run_all_tests.sh; echo TOOK $(($(date +%s) - $d1)) seconds~

** Ensure pub-required files exist: Check the following files exist

*** README.md    - pub needs the file to show Readme tab
*** CHANGELOG.md - pub needs the file to show Changelog tab
*** example dir  - pub needs this dir to show Example tab to show.

this tab appears if the project has the ~example/lib/main.dart~ file.
*** pubspec.yaml - pub needs this to show Installing tab
** *pubspec.yaml*: - Increase version number "version: 0.X.Y"
** *CHANGELOG.md*: - Add section for new version and description of changes.
** *README-source-for-md.org*:   - NOT NEEDED: Ensure all linked images are in flutter_charts/doc/readme_images.

2022-01-10: All new images are placed to readme_images by the babel ssctipt in [[*Examples with code]], so this is not needed
- For captured images, add an image to README-source-for-md.org using the regular image capture.
- Show the image links directly
- Rename the images to a readable names, both on disk (wdir-) and in org file, for example: =README-source-for-md.org_20180618_000741_0oAyud.png= to =README-source-for-md.org_iterative-layout-step-4.png=
- Move the image from ~flutter_charts~ to ~flutter_charts/doc/readme_images~


Reason for this: *From web: Images are not allowed on pub  https://pub.dartlang.org. When new images are added to README, we need to put the images somewhere outside pub, README.md must only contain links to the images. We decided to store images in a special directory ~doc/readme_images~, and point to them via github*. 

** *README-source-for-md.org*: Convert to *README.md*, and do some manual formatting after conversion 

To convert *README-source-for-md.org* to *README.md*, we need to do a few extra steps for README.md image links to be readable on https://pub.dartlang.org.

1. Ensure that the *README-source-for-md.org* file has the heading ~Table of contents :TOC:noexport:~ - this causes the TOC update on every save of the org file.
   - The :noexport: is currently needed , otherwise error Unable to resolve link: "link-converted-from-first-heading"
2. *README-source-for-md.org*: When ready to export to MD, follow the instructions in the README org file, header [[file:../../../README-source-for-md.org::*Internal notes for exporting this document][Internal notes for exporting this document]] regarding running 2 scripts, one to copy latest images to ~doc/readme_images~, and another to generate examples code, and links to images.
3. *README-source-for-md.org*: Export org to md: ~C-c C-e m m~ in the org file to create the generated md file
4. *README.md*:
   + NOT NEEDED - Delete the TOC generated by the org -> md export, the whole section , including the header named "# Table of Contents" (still needed with :TOC:noexport:)
   + NOT NEEDED - Delete the <a id="YYYY"></a> generated by org conversion: ~delete-matching-lines ^<a id=~
   + NOT NEEDED - Generate md-native TOC:
     - NOT NEEDED - Cursor on top
     - NOT NEEDED - ~M-x: markdown-toc-generate-toc~
     - NOT NEEDED - Then, ~in the generated MD TOC, remove <a id links~, as the markdown-toc-generate-toc should not add them. They are IDs on headers!. Do this:
       - rNOT NEEDED - egex replace ~ <a id=.*a>~ INCLUDING THE SPACE AT BEGINNING with NOTHING ONLY in the TOC
   + *Fix image links in the README.md* - links must be converted from the first version to the second: 
    #+BEGIN_SRC markdown
    -![img](doc/readme_images/README-source-for-md.org_20171102_180657_27063rZs.png)
    +![img](https://github.com/mzimmerm/flutter_charts/raw/master/doc/readme_images/README-source-for-md.org_20171102_180657_27063rZs.png)
    #+END_SRC
   + The above is achieved with:
     - replace-regex ~[\/]*doc/readme_images~ to  ~https://github.com/mzimmerm/flutter_charts/raw/master/doc/readme_images~
     - in the README.MD file, the result inside <img src= sections should look like ~https://github.com/mzimmerm/flutter_charts/raw/master/doc/readme_images/ex31AnimalsBySeasonNoLabelsShown_verticalBarChart.png~

** ~dart format --line-length=120 lib~
** ~dart format --line-length=120 example~
** ~dart format --line-length=120 tool~
** ~dart format --line-length=120 integration_test~
** ~NO dart format test~
** ~flutter analyze~ # Analyze and fix errors Must be clean to run dartdoc
** ~dartdoc~ # Generate documentation in doc/api directory as static HTML files.
First install dartdoc latest compatible with SDK:

~flutter pub global activate dartdoc~
** ~flutter clean; flutter pub upgrade; flutter pub get; tool/test/run_all_tests.sh~ which runs ~flutter test~ and integration and drive tests. Also see https://flutter.io/testing/
** ~git add .; git commit; git push~
** ~git checkout master; git fetch; git pull; git merge flutter_charts_v2~
** ~git push origin master~
** *README.md*: on https://github.com/mzimmerm/flutter_charts - check if image links in README.md have a full path to http
** ~flutter pub publish --dry-run~
** Once the above has no errors or warnings: ~flutter pub publish~
** The above will ask for authorization (will generate an auth link and go to the link in browser)
** Message: The pub client has been successfully authorized. You may now use it to upload packages and perform other tasks.

This just finishes up the publish.

** Check the published package: https://pub.dartlang.org/packages/flutter_charts
*** Make sure that:
- all tabs look good, 
- links in README and CHANGELOG work,
- check if doc was generated
- Go over issues in the analyses tab: https://pub.dartlang.org/packages/flutter_charts#-analysis-tab-
** Test the package that was just published
*** ~cd flutter_charts_sample_app; flutter pub upgrade; flutter pub get; flutter run~

* DONE Enhancements Done
** DONE 1. Add ability to create a Table of Contents to README-source-for-md.org
- [X] Install toc-org package
- [X] Add to init.el
  #+BEGIN_SRC elisp
  (if (require 'toc-org nil t)
  (add-hook 'org-mode-hook 'toc-org-enable)
  (warn "toc-org not found"))
  #+END_SRC
- [X] Every time README-source-for-md.org is saved, first heading with a :TOC: tag will be updated with the current table of contents.
- [X] So nothing special need be done after the above is configured.

** DONE 2. Items, bugs, refactorings Implemented
*** DONE Re-implement the layout more generically and clearly. Space saving changes such as /tilting/ labels
*** DONE Labels auto-fit: scale, tilt or skip labels to fit using *HorizontalLabelsContainer*
*** DONE Add integration tests and ability to take screenshot and compare

See https://dev.to/mjablecnik/take-screenshot-during-flutter-integration-tests-435k on how to take screenshots in Flutter

1. Setup integration tests: https://flutter.dev/docs/cookbook/testing/integration/introduction
2. Create an integration test chart_test_1.dart, which will run same code as the app flutter_charts/lib/main.dart 
3. *Must start an AVD device - without this, errors about 'dart:ui' not found!*
4. Command line, run: ~flutter test integration_test/chart_test_1.dart~. Can add -d device.
5. Experiment with ability to run the test. Experiment with clicking on the + button in the test.
6. Replace test_driver/integration_test.dart code with
   #+begin_src dart
     import 'dart:io';
     import 'package:integration_test/integration_test_driver_extended.dart';

     Future<void> main() async {
       try {
         await integrationDriver(
           onScreenshot: (String screenshotName, List<int> screenshotBytes) async {
             final File image = await File('screenshots/$screenshotName.png').create(recursive: true);
             image.writeAsBytesSync(screenshotBytes);
             return true;
           },
         );
       } catch (e) {
         print('Error occured: $e');
       }
     }
   #+end_src
   This adds onScreenshot event handler to integration tests
7. To integration_test/app_test.dart, before all testWidgets where tests are initialized, add this code:
   #+begin_src dart
     final binding = IntegrationTestWidgetsFlutterBinding();
     IntegrationTestWidgetsFlutterBinding.ensureInitialized();
   #+end_src
8. To the code of the test, at the point you want to take the screenshot, add this code
   #+begin_src dart
     await binding.takeScreenshot('test-screenshot');
   #+end_src
** DONE 3. Add logarithmic scale. 
**** NOTE Doc: YLabels, YScaler, and their layout in flutter_charts

ChartData yLabels and dataRowsColors behave differently.

reason is, yLabels have 2 modes:
- When yLabels passed to constructor, then they are set to non-null in argument, then manual layout is used.
- When yLabels not passed, they are not used at all! Instead an auto layout of Y is used as follows:
  - yScaler.labelInfos is used instead
    - yScaler is created from this code
      #+begin_src dart
        YScalerAndLabelFormatter _layoutCreateYScalerFromPointsColumnsData(double yAxisMin, double yAxisMax) {
          List<double> flatData =
          geometry.iterableNumToDouble(_chartTopContainer.pointsColumns.flattenPointsValues()).toList(growable: true);

          Range range = Range(
            values: flatData,
            chartOptions: _chartTopContainer.options,
          );

          // revert toScaleMin/Max to accommodate y axis starting from top
          YScalerAndLabelFormatter yScaler = range.makeLabelsFromDataOnScale(
            toScaleMin: yAxisMin,
            toScaleMax: yAxisMax,
          );
          return yScaler;
        }

        ///////////////
        YScalerAndLabelFormatter makeLabelsFromDataOnScale({
            required double toScaleMin,
            required double toScaleMax,
        }) {
          double min = _closure.min;
          double max = _closure.max;

          Poly polyMin = Poly(from: min);
          Poly polyMax = Poly(from: max);

          int signMin = polyMin.signum;
          int signMax = polyMax.signum;

          // envelope for all y values
          double from, to;

          // Need to handle all combinations of the above (a < b < c etc).
          // There are not that many, because pMin <= pMax and pDiff <= pMax.
          /* keep
          if (false && powerDiff < powerMin) {
          // todo-00-github-issue-31 : Allow start Y axis from non-zero
          // todo 1 - enable conditions where y=0 axis is not needed to show,
          //          to allow for details, mainly for lots of values.
          //          Make an option for this. Add to tests.
          from = polyMin.floorAtMaxPower.toDouble();
          to = polyMax.ceilAtMaxPower.toDouble();
        } else {
          ,*/
          // for now, always start with min or 0, and end at max (reverse if both negative).

          if (signMax <= 0 && signMin <= 0 || signMax >= 0 && signMin >= 0) {
            // both negative or positive
            if (signMax <= 0) {
              from = min;
              to = 0.0;
            } else {
              from = 0.0;
              to = max;
            }
          } else {
            from = min;
            to = max;
          }
          // keep }

          // Now make labels, evenly distributed in the from, to range.
          // Make labels only in polyMax steps (e.g. 100, 200 - not 100, 110 .. 200).
          // Labels are (obviously) unscaled, that is, on the scale of data,
          // not the displayed pixels scale.

          List<double> labels = _distributeLabelsIn(Interval(from, to)); // todo 0 pull only once (see below)

          // print( " ################ makeLabelsFromData: For ###_values=$_values found ###labeValues=${labels} and ###dataRange= ${from} to ${to} ");

          var yScaler = YScalerAndLabelFormatter(
            dataRange: Interval(from, to),
            valueOnLabels: labels,
            toScaleMin: toScaleMin,
            toScaleMax: toScaleMax,
            chartOptions: _options);

          yScaler.scaleLabelInfos();
          yScaler.makeLabelsPresentable();

          return yScaler;
        }


        List<double> _distributeLabelsIn(Interval interval) {
          Poly polyMin = Poly(from: interval.min);
          Poly polyMax = Poly(from: interval.max);

          int powerMax = polyMax.maxPower;
          int coeffMax = polyMax.coefficientAtMaxPower;
          int signMax = polyMax.signum;

          // using Min makes sense if one or both (min, max) are negative
          int powerMin = polyMin.maxPower;
          int coeffMin = polyMin.coefficientAtMaxPower;
          int signMin = polyMin.signum;

          List<double> labels = [];
          int power = math.max(powerMin, powerMax);

          // todo-1 refactor this and make generic
          if (signMax <= 0 && signMin <= 0 || signMax >= 0 && signMin >= 0) {
            // both negative or positive
            if (signMax <= 0) {
              for (double l = 1.0 * signMin * coeffMin; l <= 0; l++) {
                labels.add(l * math.pow(10, power));
              }
            } else {
              // signMax >= 0
              for (double l = 1.0 * 0; l <= signMax * coeffMax; l++) {
                labels.add(l * math.pow(10, power));
              }
            }
          } else {
            // min is negative, max is positive - need added logic
            if (powerMax == powerMin) {
              for (double l = 1.0 * signMin * coeffMin; l <= signMax * coeffMax; l++) {
                labels.add(l * math.pow(10, power));
              }
            } else if (powerMax < powerMin) {
              for (double l = 1.0 * signMin * coeffMin; l <= 1; l++) {
                // just one over 0
                labels.add(l * math.pow(10, power));
              }
            } else if (powerMax > powerMin) {
              for (double l = 1.0 * signMin * 1; l <= signMax * coeffMax; l++) {
                // just one under 0
                labels.add(l * math.pow(10, power));
              }
            } else {
              throw Exception('Unexpected power: $powerMin, $powerMax ');
            }
          }

          return labels;
        }

      #+end_src
    - yScaler notes  
      so the labels are created in "distributeLabelsIn(Interval)"
      - Interval is DATA interval - *a simple min/max value on data* (more precisely interval from ~_chartTopContainer.pointsColumns.flattenPointsValues()~ which on bar chart is added data)
      - *so the labels are simple distribution of as many labels as needed between data min/max - ChartData.yLabels are NEVER USED when not set in constructor.*

        *todo*:
        - rename _closure to _envelope
        - rename value in params in range to pointsColumnsPointsValues
        - Add test that is like RandomData but with similar real data.
**** NOTE Doc: ChartData flow in the system, data values and names, where are labels created from values 
1. ~ChartTopContainer.layout~
   - ~ChartTopContainer.setupPointsColumns~
     - ~PointsColumns~ costructor (passed TopContainer with data). Internally, this done in ~PointsColumns._createStackableValuePointsFromChartData~. In the end, *transformed data* lives in ~PointsColumns.each.PointsColumn.stackableValuePoints.each.StackableValuePoint.dataY~.
     - Result: each ~transformed~ data point from ~ChartData.dataRows is converted ==> StackableValuePoint~
2. ~YContainer.layout~
   - ~YContainer.layoutAutomatically~
     - ~YContainer._layoutCreateYScalerFromPointsColumnsData(axisYMin, axisYMax~
       - ~allStackedDataYs = _chartTopContainer.pointsColumns.flattenPointsValues()~
       - ~new Range(values: allStackedDataYs, options)~
       - ~yScaler = Range.makeYScalerWithLabelInfosFromDataYsOnScale(axisYMin: axisYMin, axisYMax: axisYMax,)~
         - This creates the disctributed labels as follows:
           - ~distributedLabels = Range.distributeLabelsIn(Interval(dataYsMinExtendedTo0, dataYsMaxExtendedTo0,))~
             - So the labels are distributed in the TRANSFORMED dataYMin, dataYMax (maybe extended)
           - ~yScaler = YScalerAndLabelFormatter(dataYsEnvelop: Interval(dataYsMinExtendedTo0, dataYsMaxExtendedTo0), labelYsInDataYsEnvelope: distributedLabels, axisYMin: axisYMin, axisYMax: axisYMax, chartOptions: _options);~
         - In the end, the ~yScaler~ scales from the (extended) dataYMin - dataYMax to the axisYMin - axisYMax. So, given a label's raw value, it will display the raw value, which is what we want.

**** DONE Add unit tests for the following unclean classes and methods, before refactoring them
- [X] util_dart.scaleValue  
- [X] Range.makeYScalerWithLabelInfosFromDataYsOnScale # This includes  Range.distributeLabelsIn(Interval)
- [ ] YScaler.scaleLabelInfos later
- [ ] YScaler.makeLabelsPresentable later

**** DONE Logarithmic Y scale
***** DONE Rename ownScale to yValueScale, toScale to toDisplayScale
***** DONE *Logarithmic scale, with existing formatters and label creators*
****** DONE Bug fix: Ex40 which is manual scale is now using logarithmic scale. Fix it.

Fix: During manual layout, LabelInfo.transformedDataValue was not set.

****** DONE Logarithms of base 10 and e
loge(10) = ln10 <==> e^ln10 = 10
loge(x) = y <==> e^y = x
log10(x) = y <==> 10^y = x <==> (e^ln10)^y = x <==> e^(ln10*y) = x <==>  ln10*y = lne(x) <==> y = lne(x) / ln10

So

log10(x) = y # substiture above for y

log10(x) = lne(x) / ln10 - where ln10 is loge(10)

~So in Dart speak~, where lne = log:

~log10(x) = log(x) / ln10~ where log(x) is loge(x) and ln10 is loge(10)

Or - with making a more math notation

log10(x) = loge(x) / loge(10)

e^loge(x) = x ; e^loge(10) = 10

****** DONE Steps to introduce logarithmic scale
 
- [X] Add data test if scale is logarithmic: only allowed if yValues are numeric and >= 0, otherwise exception, method: checkDomainAndRangeValidFor(yTransform)  
- [X] ! The above needs ChartData to contain ChartOptions. So this requires API deep changes. ChartOptions is passed to ChartData rather than ChartTopContainer such as VerticalBarChartTopContainer
- [X] NOT FOR NOW: If scale is logarithmic, enforce the setting data starts above 0
- [X] Add comments:
  - [X] LabelInfo.dataValue should ONLY be used for labels, never for data or coordinates
  - [X] *Data displayed inside the chart use transformed data values, displayed labels show raw data values*
  - [X] On  axisYMin than it is really axisYBottom (which is on the bottom of the chart, but has the max value). Similar to Max

** DONE 4. DONE in new Containers refactoring and new Layout refactoring
*** DONE Easier cleanup and refactoring after Logarithmic scale (but not related)
**** DONE Rename distributedLabels to distributedLabelYs
**** DONE Rename yLabelsDividedInYAxisRange  to manuallyDistributedLabelYs
**** DONE Manual vs Automated layout changes

- [X] Manual layout does not use Range. Make it use Range and work semantically same as manual layout:
  #+begin_src dart
    Range range = Range(
      values: allStackedDataYs,
      chartOptions: _chartTopContainer.options,
    );

    // revert axisYMin/Max to accommodate y axis starting from top
    YScalerAndLabelFormatter yScaler = range.makeYScalerWithLabelInfosFromDataYsOnScale(
      axisYMin: axisYMin,
      axisYMax: axisYMax,
    );
  #+end_src
- [X] Remove Range and pull it's functionality to YScalerAndLabelFormatter
- [X] Range only manages a list of values, that represents labels anyway! Do this:
  - [X] Move the 2 members from Range to YScalerAndLabelFormatter
  - [X] Move Range.makeYScalerWithLabelInfosFromDataYsOnScale to YScalerAndLabelFormatter private method, called from it's constructor
  - [X] Remove Range
  - [X] Fix tests and test
- [X] Manual Layout
  - [X] use terminology userLabelsDrivenLayout instead of manualLayout
  - [X] Find code commonalities between userLabelsDrivenLayout and autoLabelsDrivenLayout
  - [X] Fix manual layout to work the same as auto layout
  - [X] Test
  - [X] push
  - [X] remove UNUSED methods
  - [X] remove or rename obsolete comments
  - [X] Address todo-00-later-document 
  - [X] Address todo-00-later-not-used
  - [X] Make YScaler members and methods private
  - [X] Remove YScaler member dataYsEnvelop
**** DONE Refactor ChartOptions so the same class applies for both LineChart and VerticalBarChart

Idea: Only have one ChartOptions class, used both as LineChartOptions and VerticalBarChartOptions.

We lose: Polymorphism (ability to define methods with differenct behavior) on LineChartOptions and VerticalBarChartOptions.

Why it's OK: We are trying to remove all behavior from options anyway, in fact, removing all options.

- [X] pull loose LineChartOptions members to a LineChartOptions 
- [X] Rename in place ChartOptions to CommonChartOptions 
- [X] convert VerticalBarChartOptions to empty class
- [X] Change ChartOptions to extend BaseChartOptions, and add 2 members,  LineChartOptions, VerticalBarChartOptions
- [X] Remove any references in code to LineChartOptions, VerticalBarChartOptions.
- [X] Make code and test work.
**** DONE Add an intermediate between CustomPaint and Chart: ~VerticalBarChart extends widgets.CustomPaint~

Add ~FlutterChart extends  widgets.CustomPaint~
Then ~VerticalBarChart extends FlutterChart~
Then ~LineChart extends FlutterChart~
**** DONE Add note that Envelope always means Envelope of List<double>. It is always an Interval, either a closure of the List<double>, or it's extension to start or end at 0.
**** DONE Rename any _container, container members to topChartContainer if it is actually ChartableTopContainer
**** DONE ChartTopContainer related - replace final _private + getter with just private

Look for places like this

  final ChartTopContainer _chartTopContainer;
  ChartTopContainer get chartTopContainer => _chartTopContainer;

  What is the general need for a private final with a public getter? Isn't it better to just have a non-private final?  Yes. Changed that.
**** DONE Rename DataRows to RawDataRows, DataRow to RawDataRow.

*We only use dataRows and dataYs which represent transformed data, so make it consistent*
- [-] Rename DataRows and related to RawDataRows
- [-] Rename DataRow to RawDataRow.
- [X] Rename LabelInfo.dataValue -> LabelInfo.rawDataValue
- [X] Rename LabelInfo.transformedDataValue to dataValue
- [ ] In the end, 'data', 'dataY' represents transformed, not-stacked not-scaled. 'rawData' 'rawDataY' represents original not-transformed data.
- [ ] This is nice because 'data' is short, and most of the codes deals with 'transformed data', named 'data', which is short . Places in code where we see 'rawData' are not-transformed original data.
**** DONE LabelInfo: Make some parts a getter rather than member

- [X] Convert LabelInfo.rawDataValue to getter
- [X] Convert LabelInfo.axisValue to getter
**** DONE Remove ~ChartOptions get options => data.chartOptions;~ and let the options be reached as chartTopContainer.data.chartOptions. Then maybe rename chartTopContainer.data.chartOptions to chartTopContainer.data.options.
**** DONE Options access:

- [X] Go through if there are places that pass ~options~ to constructors, and see if they are needed - in ChartAreaContainers, they can be replaced with ~chartTopContainer.data.options~
- [X] Go through if there are places with ~_options~ or ~options~ members, and see if they can be replaced - see the above point.
- [ ]
**** DONE Try to make as many members as possible final:
- [X] LabelInfo
- [X] YSCaler
- [-] Containers - LATER
- [ ] 
**** DONE Rework imports to use the ~import '../presenter.dart'~ method rathern than importing the whole flutter_charts package.
**** DONE Move all painting from ChartPainter.paint to ChartContainer.paint

**** DONE Remove _paintYLabels and similar, just replace with content of the method.

*** DONE Refactored SOME Containers = LegendContainer, LegendItemContainer, LabelContainer

*** DONE NOOOO - Split Container to Layouter and Painter

At the moment, *there is no need to split Container to Layouter and Painter*. I do not think we will ever use Layouter by itself, without paint(Canvas). Layouters such as Column or Row, when painted, just call their children.

So this was NOT done.

*** DONE New Container structural changes: Make Containers (Layouters?) a hierarchy and add fields, towards "Everything is a container"

- [X] Add ~BoxContainerParentSandbox parentSandbox~ and move parent managed fields here
- [-] Add hierarchy fields
  - [X] ~parent~ [on top member it should be Contaier.root (in ChartContainer)]
  - [X] ~children~ should be just a List<Containers>
  - [ ] ~traverse()~ 
  - [X] ~flatten()~ 
  - [ ] ~isUniqueName()~
  - [X] ~isRoot()~
  - [X] ~addChild(Container)~ - can never be root
  - [X] ~name~ not null, required
- [ ] Add Constructors
  - [ ] ~Container.root~, configure as root
    - member ~name~ set in all constructors or defaults to random string, functions as unique key. later Ensure name unique in hierarchy. 
  - [ ] constructor from children by passing children: List<Container>
- [ ] Layout related stuff
  - [?] LATER/NOT AT ALL: add member ~boxContainerConstraints~ - NOT NOW, LATER - ONLY PASSED TO LAYOUT, NO NEED TO HOLD ON TO - But flutter holds on to constraints in RenderObject 
  - [L] implement default method ~layout(BoxContainerConstraints)~ - see [[Layouter general function]]
  - [?] ~applyParentOffset~ removed (BUT KEEP AT FIRST) - replaced by calculateAndSetActualChildrenLayoutSizesAndOffsetsInSelf
    - applies offset on self (call super)



*** DONE Constraints and LayoutExpansion: Refactor LayoutExpansion to BoxContainerConstraints and clarify role of BoxContainerConstraints
**** DONE DONE in Constraints
***** DONE Study function of LayoutExpansion and remove the GrowDoNotFill, TryFill, definition, parameters, arguments, and passing down entirely.

- LayoutExpansion is actually a fake - it in facts holds on to the Container size before and after layout. Eventually, convert it to "layoutSize" field instead of the getter.

***** DONE LayoutExpansion: more study and cleanup - pass to layout instead of to Container constructor (required layoutExpansion)

I suspect, this is actually used as Container.preLayoutSize - sort of like preferredSize !!!!
- or maybe as layoutSize member that is settable, to bypass only getter getLayoutSize
  
Study it and comment, maybe rename and refactor.

Code review:

- [ ] Container._layouExpansion is ONLY set during construction, so should be doable to be final! 
- [ ] LayoutExpansion is now passed to layout as it functions basically as BoxContainerConstraints!!
-

***** DONE LayoutExpansion and Containers: remove all _layoutSize from extensions of Container, and add it as member to Container, replacing getter layoutSize in preparation of moving all these basic elements related to layout to Container.

This should be possible, and in principle relatively simple .. well it still has some leftover work below.

- [X] Remove _layoutSize from specializations of Container
- [X] Remove get layoutSize from specializations of Container 
- [X] Container layoutSize will need set and get. To set, add new private _debugLayoutSetCount. This will be interesting to know if the setter was called after initial set in layout
- [X] Make sure _layoutSize is only in Container. Outside Container, use layoutSize 


***** DONE Consider if LabelContainer needs to call layout again: places like: yLabelContainer.layout(LayoutExpansion.unused());

Not needed, commented out and tested.

***** DONE LayoutExpansion and Containers: remove all _layoutExpansion from extensions of Container AND Container. ~layoutExpansion is passed to layout, but NOT held on~

***** DONE Put back grid on the line chart.

- why did it disappear?

  Reason: In LineChartDataContainer

  #+begin_src javascript

  void paint(ui.Canvas canvas) {
    _paintGridLines(canvas);
    _drawDataPresentersColumns(canvas);
  }

  #+end_src

  The _paintGridLines was missing
***** DONE LayoutExpansion and Containers: Now when the layoutSize is holding the passed layoutExpansion, Remove from Container, all members and getters for layoutExpansion

Ok, now Nothing holds on layoutExpansion. Only passed to layout(layoutExpansion)

Note: We can add at most a getter later (Flutter RenderObject and RenderBox has get constraints)

***** DONE Move Container.dart to it's own package containter_base.dart
***** DONE NO, KEEP chartArea for now : Review use of chartArea on ChartContainer, see if it should be simply replaced with layoutSize !!!

- but express that ChartContainer layoutSize should never change, be fine



**** DONE Add BoxContainerConstraints and refactor LayoutExpansion into it

- [X] Add fields minSize, maxSize
- [X] Add Constructors, first on LayoutExpansion
  - [X] BoxContainerConstraints({Size minSize, Size maxSize})
  - [X] BoxContainerConstraints.exactBox({required Size size})
    - [X] sets min=max=size
  - [X] BoxContainerConstraints.insideBox({required Size size})
    - [X] sets min=0, max=size
  - [X] BoxContainerConstraints.outsideBox({required Size size})
    - [X] sets min=size, max=infinity
- [X] Add method size : throws exception if min != max, then return min
- [X] Code changes:
  - [X] Make width, height private (this will show lots of errors)
  - [X] Replace most LayoutExpansion constructors with .exactBox(size: Size(with, height))
  - [X] Search where LayoutExpansion.width or height is used, replace it with LayoutExpansion.size.width
  - [X] Remove members width, height
- [X] Refactor/rename LayoutExpansion to BoxContainerConstraints
 
** DONE 5. Tool updates 2022-10-10

- [X] Update Flutter to latest (v. Flutter 3.3.4 • channel stable • Tools • Dart 2.18.2 • DevTools 2.15.0)
: ~flutter channel stable; flutter upgrade~; AFTER, needed to comment out ~analyzer: ^2.8.0~ from pubspec.yaml, otherwise ~flutter pub upgrade~ fails)
- [X] Test (needed to upgrade images after OS and Flutter updates, by DELETING all screenshots_expected and screenshots_tested, then RUNNING ~run_all_tests.sh~ which will FAILed but only after creating missing images. Copy them to screenshots_expected, THEN run ~run_all_tests.sh~ again)
- [X] Update IntelliJ community edition to latest
- [X] Update Flutter plugin to latest
- [X] Test

* Naming

- (Presenter)Leaf       :: The finest visual element presented in each  "column of view" in chart - that is, all widgets representing series of data displayed above each X label. For example, for Line chart, the leaf would be one line and dot representing one Y value at one X label. For the bar chart, the leaf would be one bar representing one (stacked) Y value at one X label.
- Classes: Presenter, LineAndHotspotPresenter, VerticalBarPresenter, PresenterCreator
- Painter               :: Class which paints to chart to canvas. Terminology and class structure taken from Flutter's Painter and Painting classes.
- Classes: todo

* NOTE Older Design Notes

** Towards a new, suggested ~InternalChartData~ class - this is the class Flutter Charts will work from at it's core. *This may change significantly.*

First, let me summarize that current (unexpressed) constraints on  the current ~ChartData.dataRows~ - in essence, all corresponding list lengths must be the same:

1) Along the x axis (row wise)   : (each row in dataRows).length is the same 
2) Along the x axis (row wise)   : (each row in dataRows).length == xLabels.length 
3) Along the y axis (series wise): dataRows.length == dataRowsColors.length == dataRowsLegends.length

Basically, the ~dataRows~ member assumed to be an array (list of rows of equal length)

So towards the future, the more I was thinking the way the layouting may work, the more I am sure it is best to keep 1) for sure, and maybe 3), but drop 2) for sure to support uneven steps and skipped labels. And in all case I kept arriving at thinking the layouter would eventually convert any ~List<List<Point>>~ to a list of Y values ~List<List<double>>~ and extract the X values under each point so we have List<double> xValues. I would like to note that this structure can be made in all respects equivalent to  ~List<List<Point>>~ - we can always write adaptors in either direction. 

So I'd like to support the internal structure of ChartData as described below, and all external data in different formats/structure would have to provide convertes; this project would probably provide some basic adaptors (I am thinkig to support some basic (e.g. some Higchart type) JSON data formats out of the box.

Next, goals and non-goals of this change.

*Current goals of the ~InternalChartData~ class:*

- Define a data source class used on the the low end of chart layout. 
- Define the data source class in terms of lowest level primitives: Because in the end, all paint operations operate only with Dart ~double~ (for Y values, and Distanced X points) and Dart ~String~, we only use those primitives.
- Still allow for a simple, no frills way of clients defining their own X and Y labels directly, similar to the current ~ChartData~ 
- Provide a sufficient description for data defined as any "reasonable" object to be convertable to  ~InternalChartData~ through adaptors.
  - Data Adaptor Examples: 
    - X values is a List<String>, Y values is a  List<double>      => ~InternalChartData~
    - X and Y values are an array, e.g. List<List<double>>         => ~InternalChartData~
    - X values is a List<DateTime>, Y values is a  List<double>    => ~InternalChartData~
- Provide a converter from ~ChartData~ to  ~InternalChartData~


*Current non-Goals of the ~InternalChartData~ class. These may become goals later*
- We can rephrase the simplification of ~double~ (both for X and Y ) in terms of interfaces that allow for *order* and *distance* : let us call them ~OrdinalDimension~ and ~DistancedDimension extends OrdinalDimension~. ~OrdinalDimension~ provides order of it's points,  ~DistancedDimension~ provides distance of it's points. Basically substitute ~double~ everywhere above and is the definition of ~InternalChartData~ with ~OrdinalDimension~ . *BUT I HAVE A TODO HOW TO DO THIS RIGHT*. 
  - ~double DistancedDimension.distance(DimensionPoint point, DimensionPoint point)~ // must satisfy distance properties
  - ~int OrdinalDimension.comparePoints(DimensionPoint point, DimensionPoint point)~
  - ~double DimensionPoint.toDouble()~ - basically, distance from origin on the chart. Required(?) to find a minimum, maximum; We require this for OrdinalDimension as well, where it duplicates order - basically the result is the sequence in a the list of ordered dimension points.

For now all members are public but that may change. Also will describe some constructors later.

#+BEGIN_SRC dart

  /// Used internally as a "data source" by Flutter Charts.
  /// 
  /// Data sources in other formats should provide adaptors to convert to this 
  ///   internal format.  
  /// 
  /// Data Adaptor Examples (just as an overview): 
  ///   - X values is a List<String>, Y values is a  List<double>      => ~InternalChartData~
  ///   - X and Y values are an array, e.g. List<List<double>>         => ~InternalChartData~
  ///   - X values is a List<DateTime>, Y values is a  List<double>    => ~InternalChartData~
  ///   - ~ChartData~                                                  => ~InternalChartData~
  class InternalChartData {

    /// Data defined in terms of the low level primitives - a Dart double.

    List<List<double>> dataRows = new List(); 

    /// Map from x values to xLabel. It's keys and values,
    /// decide whether the X labels displayed are User-Provided or Data-Generated. 
    ///
    /// See the [validateX] method which describes how construction of this map
    ///   affects the labels construction as User-Defined vs. Data-Generated.
    ///
    ///   Below is a summary from [validateX]. This may sound complicated, 
    ///   it exists to *also allow clients
    ///   a simple, no frills way of defining their own X labels directly, 
    ///    similar to the current ~ChartData~ does*.
    ///
    /// 1. Overall Requirement of  [xToXLabelMap]: It is required that [xToXLabelMap]
    ///    contains as many keys as each dataRow length for all [dataRows].
    ///    *Note: If a client does not care about the actual x points, the client must set the keys
    ///        in  [xToXLabelMap] to double 1.0, 2.0 ... etc - as if they were List indexes.*
    ///
    /// 2. Ensure that label is set on all x points, or none.
    ///    So all labels or none must be provided as values of the [xToXLabelMap].
    ///
    /// 3. If labels are not null on all x keys, those labels will be used on the chart -
    ///   so this condition is interpreted as:
    ///   User (Client) provided X labels in [xToXLabelMap],
    ///     and is requesting those labels to be shown, as "User-Defined labels".
    ///
    /// 4. If labels are null on all x keys, this condition is interpreted as:
    ///    User (Client) did not provide labels in [xToXLabelMap],
    ///    and is requesting labels to be "Data-Generated". In this case, the
    ///    formatter [xLabelFormatter] must be provided.

    TreeMap<double, String> xToXLabelMap;
    
    /// Converts a x axis data value to a label representing the value at the x axis point.
    /// Required to create Data-Generated xLabels. 
    ///
    /// See the [validateX] method which describes how construction of this map
    ///   affects the labels construction as User-Defined vs. Data-Generated. 

    String Function(double) xLabelFormatter;


    /// Map from y values to yLabel. **The only purpose of [yToYLabelMap] is to chart Ordinal Y values with User-Defined labels**
    ///
    /// This is similar to [xToXLabelMap] in structure, but the internal use and
    /// assumptions differ.    
    ///
    /// See the [validateY] method which describes how construction of this map
    ///   affects the labels construction as User-Defined vs. Data-Generated.
    /// 
    ///   Below is a summary from [validateY].
    ///
    /// 1. If `yToYLabelMap.length > 0` this condition is interpreted as:
    ///   User (Client) provided Y abels in [yToYLabelMap],
    ///     and is requesting those labels to be shown, as "User-Defined labels".
    ///
    /// 2. Iff `yToYLabelMap.length == 0` , this condition is interpreted as:
    ///    User (Client) did not provide labels in [yToYLabelMap],
    ///    and is requesting labels to be "Data-Generated". In this case, the
    ///    formatter [yLabelFormatter] must be provided.
    ///
    /// 3. Overall Requirement of [yToYLabelMap]: There is no requirement on number of entries 
    ///     in [yToYLabelMap]. 
    ///
    /// 4. If the length of [yToYLabelMap] is not zero, ensure that label is not null on all y points.
    ///
    /// 5. Each entry's value shows one label on the Y axis. 
    ///    
    /// 6. Each entry's key is scaled to the scale of the outer envelope of [dataRows] and set of [yToYLabelMap.keys],
    ///    and the `entry.value` is used as label, on Y position corresponding to the point of `entry.key`
    ///    on the outer envelope.
    ///

    TreeMap<double, String> yToYLabelMap;

    /// Converts a y axis data value to a label representing the value at the y axis point.
    /// Required to create Data-Generated yLabels. 
    ///
    /// See the [validateY] method which describes how construction of this map
    ///   affects the labels construction as User-Defined vs. Data-Generated. 

    String Function(double) yLabelFormatter;


    /// Legends list. Currently has to be set, but can contain empty Strings
    ///  (in which case todo 1 -take that as a hint user does not want the legend section).

    List<String> dataRowsLegends = new List();

    /// Colors list. Currently has to be set. todo 1 - If not set, default to reasonable colors.

    List<ui.Color> dataRowsColors = new List<ui.Color>();


    ////////////////////////// Added also todo 1 **not planning to implement yet** ////////////////////

    /// - If [true], then the x values keep distances in data: For example, if xs = [1,2,20, 200], 
    ///   then the (relative, scaled) distances between [1,2,20, 200], are preserved,
    ///   so that 1,2,20 will be squished on the left. The only chart type where this is allowed
    ///   is the line chart.
    ///   This setting mathematically means that we view the x axis values using
    ///     a proper real value distance as it's distance (in addition to viewing them ordered).
    /// - If [false], then  then the x values will be "equidistanced": For example, if xs = [1,2,20, 200], 
    ///   then the (relative, scaled) distances between [1,2,20, 200], are the same,
    ///   so that 1, 2, 20, 200 will be evently layed out along the x axis.
    ///   This setting mathematically means that we view the x axis values as ordered (ordinal) labels,
    ///     ignoring the distance between them (when taken as numbers)
    ///
    /// A note: X values [xs] are always ~Ordinal~ (ordered). 

    bool keepXValuesDistances
    
  }

  /// Validate the state of values. This code provides a set of rules this object members must satisfy.
  void _validate() {
    _validateX();
    _validateY();
  }

  void _validateX() {

    if (xToXLabelMap == null) {
      throw Error("xToXLabelMap must be defined!");
    }

    for (dataRow in dataRows) {
      if (dataRow.size != xToXLabelMap.size) {
        throw Error("Each Data row must be same size as xToXLabelMap");
      }
    }  
    
    // The setting of either keys or values or both determines the labels construction 
    //   as User-Defined or Data-Generated.
    // The section below describes the options and combinations.
    if (xToXLabelMap.isEmpty()) {
      // no data, return
      return;
    }

    // Overall Requirement of  [xToXLabelMap]: It is required that [xToXLabelMap]
    //    contains as many keys as each dataRow length for all [dataRows].
    // *Note: If client does not care about the actual x points, client must set the keys
    //        in  [xToXLabelMap] to double 1.0, 2.0 ... etc - as if they were List indexes.*
    
    // Ensure that label is set on all x points, or none.
    // So all labels or none must be provided as values of the [xToXLabelMap].
    if (xToXLabelMap.first.value != null) {
      xToXLabelMap.each( (x, labelValue) {
        if (labelValue == null) throw Error(" all labels or none must be provided as values of the [xToXLabelMap]");
      });
    }
    if (xToXLabelMap.first.value == null) {
      xToXLabelMap.each( (x, labelValue) {
        if (labelValue != null) throw Error(" all labels or none must be provided as values of the [xToXLabelMap]");
      });
    }

    // If labels are not null on all x keys, those labels will be used on the chart -
    //   so this condition is interpreted as:
    // User (Client) provided labels in [xToXLabelMap],
    //   and is requesting those labels to be shown, as "User-Defined labels".
    if (xToXLabelMap.first.value != null) {
      // Labels will be User-Defined.
      if (xLabelFormatter is not null) {
        throw Error("xToXLabelMap defines User-Defined labels, xLabelFormatter should not be set");
      }
    }

    // If labels are null on all x keys, this condition is interpreted as:
    //  User (Client) did not provide labels in [xToXLabelMap],
    //   and is requesting labels to be "Data-Generated". In this case, the
    //   formatter [xLabelFormatter] must be provided.
    if (xToXLabelMap.first.value == null) {
      // Labels will be Data-Generated.
      if (xLabelFormatter is null) {
        throw Error("xToXLabelMap does not define User-Defined labels. xLabelFormatter must be set, to create Data-Generated x labels.");
      }
    }
  }

#+END_SRC

Also, although "from a separation of data and view" principle I originally put some of the settings that define the chart "view" onto ChartOptions, I plan to move them to ChartData, and InternalChartData.

- [ ] ChartOptions.useUserProvidedYLabels -> ChartData
- [ ] ChartOptions.yLabelUnits -> ChartData
- [ ] ChartOptions.toLabel(label) -> ChartData
- 

* Consider Change naming conventions to WX, HY, CY, CX so all names are consistent 
   - whateverOX (width along x axis    - when context is offset of some other element)
   - whateverOY (height along y axis   - when context is offset of some other element)
   - whateverCX  (X coordinate  )       - if it is just a point
   - whateverCY  (Y coordinate  )       - if it is just a point
   - rare use below v
   - whateverRX (width along x axis  - when context is rectangle)
   - whateverRY (height along y axis  - when context is rectangle)
   - whateverFromCY (Y coordinate from ) - if it is a point which is part of a line
   - whateverToCY (Y coordinate to )     - if it is a point which is part of a line
   - whateverFromCX (Y coordinate from ) - if it is a point which is part of a line
   - whateverToCX (Y coordinate to )     - if it is a point which is part of a line

* Flutter beginner: Experimenting with Flutter using Flutter Charts

This section describes, very briefly with links, how to install Flutter, and the Flutter Charts package.

This section We describe running Flutter Charts in development mode on your device (Android, iOS - follow 1, 2 or 3, 4 and 6), or alternatively on a device emulator (device emulator running from an IDE such as IntelliJ with Android Studio installed - follow 1, 2 or 3, 5, 6 or 7).

1. Install Flutter on your computer. See the installation section on https://flutter.io/.
2. Clone flutter_charts code from Github to your computer. Needs git client.
 
  #+BEGIN_SRC sh
  cd DIRECTORY_OF_CHOICE
  git clone https://github.com/mzimmerm/flutter_charts.git
  # clone will create directory  flutter_charts
  cd flutter_charts
  #+END_SRC

3. (Alternative to 2.): Download and unzip flutter_charts code from Github
   - Browse to  https://github.com/mzimmerm/flutter_charts.git
   - On the righ top, click on the "Clone or Download" button, then select save Zip, save and extract to  DIRECTORY_OF_CHOICE
   - cd flutter_charts
4. Prepare a physical device (must be set to Development Mode "On") to run applications from your computer. Then connect a android device in development mode to your computer. See https://www.kingoapp.com/root-tutorials/how-to-enable-usb-debugging-mode-on-android.htm 

5. (Alternative to 4.): Prepare and start an Android device emulator on your computer.
   - Install Android Studio: see https://developer.android.com/studio/index.html

   - Install an IDE such as IntelliJ with Flutter plugin. See https://flutter.io/intellij-setup/

6. Run Flutter Charts demo app from command line (this will work in both method 4. and method 5.)

   #+BEGIN_SRC sh
   cd DIRECTORY_OF_CHOICE/flutter_charts 
   flutter run example/lib/main.dart
   #+END_SRC

7. (Alternative to 6.) Run  Flutter Charts demo app from IDE. This will work only with method 5. 
  - Start IntelliJ IDE, create a project in the ~DIRECTORY_OF_CHOICE/flutter_charts~ start an Android emulator, then click on the Run button in Intellij (which should show the ~file:../../../example/lib/main.dart~ in the run button).
                      
* NOTE Allowed todos

--- only allowed comments
00
00-last
00-last-last
00-doc
-
01
01-doc
01-last //rare use
-
02
02-last //rare use

* IN-PROGRESS Flutter Charts Enhancements
** LATER Enhancements in progress or planned - priority order

*** Create a document / image showing chart layout and spacing - show option variables on image
Also:
- document applyParentOffset and pull from Container?
- go over Container and document

*** Add formatter for YLabels.
*** Option additions that control look:
**** Add options to hide the grid (keep axes)
**** Add options to hide  axes (if axes not shown, labels should not show?)
**** Decrease option for default spacing around the Y axis.
*** Provide tooltip support
*** Provide a few more chart types: Spline line chart (stacked line chart), Grouped VerticalBar chart etc

*** Data types
**** Independent (X value) data types
***** There should be adapters from any dependent (X value) data types:
****** Ordinal - x values spaced evenly, only sequence matters
****** Measured - x values are convertible to numbers
******* Date types
******* Number types
******* Others?
**** Dependent (Y value) data types - for now, keep double, can provide converters.

** LATER ChartData further refactoring. Add DataSetsMixin, and add DataPoint, more representing oo behavior

*** LATER Refactor and document Poly
*** LATER Look at ~PointsColumns~ as the interesting place where ChartData.dataRows are transferred to the chart. Start at ~_drawDataPresentersColumns~
*** LATER Question any place in the library importing import 'package:flutter_charts/flutter_charts.dart'; and change to import only needed sources.
*** LATER ChartData will contains DataSetsMixin contains DataPoints which is custom List<DataPoint>
*** LATER So we need new class DataSet;   DataSets is custom List of DataSet.
*** LATER So we need new class DataPoint; DataPoints is custom List<DataPoint>
*** LATER DataPoint can be any object - sort of a naked user object
*** LATER DataSetsMixin corresponds to dataRows
*** LATER DataPoints corresponds to one dataRow.
*** LATER DataSetsMixin is a mixin which provides functions that allow to extract values from DataPoint, for example
**** DataSetsMixin.xValue(DataPoint, pointIndexInSets) =>  whatever value at DataPoint is considered x // similar for Y
**** DataSetsMixinMixin provides ~default functions which extract xLabel, yLabel, yTransform~
***** DataSetsMixin.xLabel(DataPoint, pointIndexInSets) => DataSetsMixin.xValue(DataPoint, pointIndexInSets) // similar for Y
***** DataSetsMixin.yTransform

*** LATER ~DataSetsMixin must be extended as MyDataSetsMixin, implementing at least 2 methods: xValue and yValue, see aboce~
*** LATER What options are controlled on the ChartData level? What on the DataSetsMixin level?
*** LATER ~???? Move ChartOptions to ChartData ??? Or some other redesign using configurations ???~
**** TODO ~Move function _options.yContainerOptions.valueToLabel to function ChartData.yLabelFormatter and allow to pass it and store as member~
****** TODO This is the first crack on removing ChartOptions completely and move it to ChartData
****** TODO ~ChartData must be passed to Range, along with options, to make the transforms available~
**** TODO Similar to above, ~Move function ChartOptions.YContainer.yTransform to ChartData and allow to pass it and store as member. Defaults to identity~ 
**** TODO ~Finish moving ChartOptions entirely to ChartData
*** LATER Replace y label formatter and scaler with a more elegant, see pilot project - I added one there. See todo-00-last-last
*** LATER If line chart, add option that allows to start on non-zero
    - add option userProvidedYLabelsBoundaryMin OR startYLabelsOnMinimumDataValues.
    - test  on values like 10,000 - 11,000.
    -
*** LATER Allow to create multiple charts (combined chart) in one graph - for example, line and bar chart in one graph, on same or different Yaxis (and labels), same or different xAxis (and labels).
This needs entity model change:
- current ChartData and ChartOptions are kept on ChartTopContainer
- current data structure is as follows: ChartData -> DataSetsMixin -> DataPoints - unchanged
- currently ChartOptions is set on Painter along with ChartData;  available from any Container by reaching to parentContainer or topContainer
- need to allow/add member ChartOptions on DataSet (default still on the ChartTopContainer, placed there from Painter)
- need to allow/add member presentAs on DataSet (presentAs line chart or bar chart) 
- need to allow xLabels and yLabels on DataSet ?? How ??
- we allow to set both options AND enum chartType on ChartDataRows
- we add CombinedChart (in addition to LineChart and VerticalBarChart) - CombinedChart must allow to set  
Now this presents a problem as to API: Now we are not creating LineChart, or VerticalBarChart, but a Chart WITH LineChart and VerticalBarChart in it. SO MAYBE THE DISTINCTION BETWEEN LINE AND BAR IS ON THE
** LATER Misc LATER Around Container and Layout
*** LATER Later in Container refactoring: Convert all Presenter, PointsColumn, PointsColumns etc to Containers but keep the code structure the same
*** LATER Morph: Consider making ChartTopContainer.data.dataRows, and everything else except ChartOptions private, and provide a way to construct  ~PointsColumns~ in ~ChartData~ like _createStackableValuePointsFromChartData does.
*** LATER Refactor StackableValuePoint

2 areas:

**** Around nextRightColumnValuePoint

This is often marked as todo-11-later
The StackableValuePoint maintains a link to predecessor, via it's ~predecessorPoint~ member.
However, there is also a need (only in LineAndHotspotPresenter) to maintain a link to successor.
This successor is named ~nextRightColumnValuePoint~, set in _createStackableValuePointsFromChartData using ~nextRightPointsColumn~, and passed around so much.

~Can we remove the nextRightColumnValuePoint everywhere, and place it on StackableValuePoint as successorPoint?~
Then we could also remove all the passing around of ~nextRightColumnValuePoint~.

  LineAndHotspotPresenter({
    required StackableValuePoint point,
    StackableValuePoint? nextRightColumnValuePoint,

    
**** Around removing all scaled values, leaving only scaledFrom, scaledTo Offset.

*** LATER Move all re-layout specific settings from options to DefaultIterativeLabelLayoutStrategy
** NOTE 1. Containers structure analyzed

*** NOTE How do we want the Containers lifecycle eventually?

- Generally, Containers lifecycle should be as follows.
  - Create Container Hierarchy. This is specific, but for Chart, we should just add containers we know of
    - create Root (ChartContainer)
    - create and add all children 
  - Layout
    - called by root.layout(BoxContainerConstraints)
    - side effects
      - set layoutSize on all members in hierarchy (currently not done)
      - set offset (applyParentOffset) on all members in hierarchy 
  - Paint 
  
*** NOTE Containers and Container-like classes overview

- ~ChartContainer~
  - ~PointsColumns~ pointsColumns; // NOT a container  - created from DataRows.
  - ~LegendContainer~ extends ChartAreaContainer 
    - has List<LegendItemContainer> _legendItemContainers  // is container, checked all the way down
  - ~YContainer~
    - has List<AxisLabelContainer> _yLabelContainers; // is container, checked all the way down
  - ~XContainer~ 
    - has List<AxisLabelContainer> _xLabelContainers; // is container, checked all the way down
  - ~DataContainer~
    - has ~GridLinesContainer~ _xGridLinesContainer; // is container, checked all the way down
    - has ~GridLinesContainer~ _yGridLinesContainer; // is container, checked all the way down
    - has ~PresentersColumns~ presentersColumns (is List<PresentersColumn>; // NOT a container
      - ~PresentersColumns~ // NOT a container
        - During constructions, calls self(CustomList).add(PresentersColumn)
      - ~PresentersColumn~  //  NOT a container 
        - ~List<Presenter> presenters;~
        - During construction, calls ~_createPresentersInColumn~
          - accepts:
            - ~PointsColumn~ // END. NOT a container
              - has ~List<StackableValuePoint> points;~
            - OR
            - ~List<StackableValuePoint> fromPoints,~
          - ~creates the VerticalBarPresenter and LineAndHotspotPresenter from one StackableValuePoint~: 


** DONE-THIS-ITERATION 2. Implement new Layouter algorithm
*** TODO Look into remaining usages of "ui.Size get layoutSize"
*** TODO Core Problem of layout *Maybe not a problem, see useExistingChildrenOrCreateChildren* - we are creating new Containers inside layout: We are creating legendItems in legendItemContainer.layout

This is a core design issue. Think about this and review. This may not be salvageable. 

Thoughts:

- Maybe the lifecycle needs to be:
  - setup() - Create top Container and Children - all of them, for example, all labels 
  - layout() - Layout Container and children. If there is not enough space, delete some containers created during setup(), or skip them in layout  
  - paint() - Paint the layed out Containers, skipping those marked to skip

*** NOTE ~NOT USED : Layouter algorith #1~ 
*The one-pass layout method in a Container* (or in Layouter mixin if we put Layouter on Container) should work like this:

1. *BoxContainerConstraints is passed down* to layout call.                                               parent context: ~Size childPreferredSize = child.layout(boxContainerConstraintsDefinedByParent)~  <= side effect: child.size is set (=childPreferredSize) 
2. *PreferredSize is returned up* from layout and also stored on child (happens also in 1).               
3. Once we know all children sizes:
4. Parent decides, based on it's layout algorithm,
   the size and position to actually give to each child :                                    parent context: calculateAndSetActualChildrenLayoutSizesAndOffsetsInSelf() <= layoutSize effect: child.layoutSize [overrides previous value] and child.offset (within parent) [new value] is set on each child. this.layoutSize and this.offset is set on me (parent)
6. Step 4 includes *Parent sets actual layoutSize and position down on child*.


*TAKEAWAY 1*: Each Layout (or Container?) has _constraints as a member. Default is FlowConstraints. Generally, each specific Layout class should have a specific Constraints class

*TAKEAWAY 2*: Layout (or Container?) defines layout(Constraints) which should NOT be overriden, and layoutWithConstraints() which is to be overriden. layoutWithConstraints() should generally distribute available Constraint among children, set child.constraints, and call child.layout(child.constraints) for all children

*TAKEAWAY 3*: Stuff around getMinIntrinsicWidth/getMaxIntrinsicWidth on every child

*TAKEAWAY 4*: - see RenderWrap (extends RenderBox extends RenderObject) - this seems to have lots of interesting stuff
See also: ~childSize = layoutChild(child, childConstraints);~

*TAKEAWAY 5*: computeDryLayout(Constraints) / getDryLayout(Constraints) - This method should return the [Size] that this [RenderBox] would like to be given the provided [BoxConstraints]. This layout is called "dry" layout as opposed to the regular "wet" layout run performed by [performLayout] because it computes the desired size for the given constraints without changing any internal state.

#+begin_src dart

  /// Size per container during processing.
  List<Container> children;
  List<Container> renderedChildren;
  Container parent;
  Offset offset; // todo-00-last : is this from base class?
  bool isRendered;
  void setRendered;
  /// Parent data
  Size size;
  Constraint constraint;
  Offset offsetInParent; // result of step 23
  
  List<Container> step01UseExistingChildrenOrCreateChildren();

  Offset findChildOffsetIn(childIndex, List<ContainerSize> childrenContainerSizes);

  /// Given the constraints passed to layout, suggest how they should be distributed to children.
  /// This is layout specific. Most layouts will suggest for each child, the full constrains passed to it!
  /// Only if children are greedy and take too much, this is called again
  void step11SetConstraintsOnChildrenFromMy(Constraints myConstraints) { /* todo-00-last */ };

  /// side effects:
  /// - Set child.size on all children
  void step12AskChildrenToCallLayoutThenSetDesiredSizes() {
    for (child in children) {
      // todo-00-last
      child.layoutStep1AndSetSize();
    }
  }

  /// Final constraints set on children
  void step21DistributeConstraintsOnChildrenBasedOnDesiredSizes() { /* todo-00-last */ };

  /// Final sizes determination
  void step22AskChildrenToSetFinalSizesWithinTheirConstraints() { /* todo-00-last */ };

  /// Final layout step
  void step23OffsetChildrenInMeBasedOnFinalSizesAndMyLayoutPropertiesAlsoSetMySize() { /* todo-00-last */ };

  // Final apply parent offset
  void step24ApplyParentOffsetsOnChildren() { /* todo-00-last */ };


  /// Layout means to establish size of this component and offset it in parent.
  /// Layout in this implementation is iterative by asking children to layout. All called methods are also iterative
  /// side effects:
  /// - Set child.size on all children
  /// - Set child.constraint on all children
  Size layout(Constraints constraints) {

    _children = step01UseExistingChildrenOrCreateChildren(); // return _children by default

    // Sizes from Constraints Pass 1
    step11SetConstraintsOnChildrenFromMy(constraints); // Just set child.constraints = constraints on all children
    step12AskChildrenToCallDesiredLayoutThenSetDesiredSizes(); // call child.layout(child.constraint)

    // Sizes from Constraints Pass 2
    step21DistributeConstraintsOnChildrenBasedOnDesiredSizes();
    step22AskChildrenToSetFinalSizes();

    // Layout children within me 
    step23OffsetChildrenInMeBasedOnFinalSizesAndMyLayoutPropertiesAlsoSetMySize();
    // ^^ This is the core of layout. Maybe this comes from a mixin. Needs lots of helper methods.
    //    Helpers for Row container:
    //      OffsetSizes


    // Apply offset from _offset
    step24ApplyParentOffsetsOnChildren();

    return size;
  }

  // In Flutter, performLayout() often calls layout(Constraints), and Constraints live on RenderObject (Container)
  // In Flutter, Constraints is NOT a widget

  class OffsetSizes {
    Offset startOffset;
    List<Size> sizes;
    mainAxisAlign from enum AxisAlign = { max, center, min }
    crossAxisAlign from enum AxisAlign = { max, center, min }
    void convertSizesToRectangles();
    List<Offset> offsetSizesAccordingToAlign();

  }
#+end_src


*** DONE ~USING: Layouter algorith #2~

Core ideas

- [X] BoxContainer 
- [X] add abstract rootLayout() - assumes constraints set!!
- [X] Rename ChartTopContainer to ChartRootContainer
- [X] NOOO : ChartRootContainer extends RootBoxContainer
- [X] Add to BoxContainer, field _layoutSandbox, intended to be changed by the owner (not parent)
- [X] BoxContainerSandbox new class
  - fields childrenGreedyAlongMainLayoutAxis, childrenGreedyAlongCrossLayoutAxis List of children with Size infinity in that direction
  - fields childrenInLayoutOrder
  - fields mainLayoutAxis, crossLayoutAxis, set to none, X, Y, default none. add method isLayout, returns true if any of the layoutAxis is set
- [X] Allow 0, 1 children to be greedy in MainLayoutAxis, otherwise exception
- [X] ~rootLayout()~
  - [X] ~step00_Recurse_createChildrenOrUseChildrenFromConstructor()~ // children should NOT need constraints or layoutSize during construction
    - if (children not empty) return
    - create child1
    - addChild(child1)
    - call child1.step00_Recurse_createChildrenOrUseChildrenFromConstructor()
      .. etc
  - [X] ~step10_Recurse_CheckForGreedyChildren_And_PlaceGreedyChildLast~
    - sets up childrenGreedyAlongMainLayoutAxis,  childrenGreedyAlongCrossLayoutAxis
    - if exactly 1 child greedy in MainLayoutAxis, put it last in childrenInLayoutOrder, otherwise childrenInLayoutOrder=children
  - [X] this._layoutSandbox.constraints = passedConstraints 
  - [X] ~step20_Recurse_CalculateAndSetChildrenConstraints_FromMyConstraints()~ // layout specific. only children changed, then next method. Default sets same constraints
    - // node-pre-descend
    - // node-descend  
    - for (child in children)
      - // child-pre-descend
      - child.constraints = this.constraints
      - // child-descend
      - child.step20_Recurse_CalculateAndSetChildrenConstraints_FromMyConstraints()
      - // child-post-descend
    - // node-post-descend     
  - [X] ~step30_Recurse_AskChildrenToSetLayoutSizesWithinTheirConstraints_NodePostDescendOffsetChildrenInMe()~
    - for (child in children)
      - ~child.step30_Recurse_AskChildrenToSetLayoutSizesWithinTheirConstraints_NodePostDescendOffsetChildrenInMe()~
    - // node-post-descend : All children processed or no children
    - ~step31_OffsetChildrenInMeBasedOnTheirSizesAndMyLayouter_ThenSetMySize()~
      - for (child in children)
        - child.offset += previousChild.offset + previousChild.size;  // layout specific
      - this.size = sum of children sizes; // layout specific



** IN-PROGRESS-NOW Core Layouter Rules

These are the rules we implement

1. [ ] ~newCoreLayout~ implementation must ensure resulting ~layoutSize~ is within the passed constraint; ~paint()~ must ensure all painting is within ~layoutSize & offset~ (layout size offset by offset) from layout.
2. [ ] Each BoxContainer must build itself and immediate children in ~buildContainerOrSelf~. Details: do this by calling ~addChild~, then, for all children calling ~child.buildContainerOrSelf(this)~
3. [ ] ~layout()~  should never be called, except on top
4. [ ] ~newCoreLayout~ on self or children should NEVER be called in ~buildContainerOrSelf~
5. [ ] Important: When migrating from old layout to new layout,            move the code from layout() to buildContainerOrSelf(parentBoxContainer).            layout() should not be called on new layout, except on 'fake' root.
6. [ ] Important: Ensure (manually for now), that each ~BoxContainer~:
   - EITHER wraps it's children in auto-layouter (~RowLayouter or ColumnLayouter~), and uses non-overriden default ~newCoreLayout~
   - OR     adds its' children directly, and uses overriden ~newCoreLayout~ which lays out children manually in code, similar to what we do in old ~layout~
7. [ ] Allow 0, 1 children to be greedy in MainLayoutAxis, otherwise exception
8. [ ] OLD
#+BEGIN_SRC dart
  /// Create and add children of this container.
  // todo-done-01 : Removed. Each BoxContainer must build itself using buildContainerOrSelf
  /*
  void rootStep2_Recurse_buildContainerHierarchy(BoxContainer parentBoxContainer) {
    late BoxContainer selfOrReplacedWithContainer;
    if (isRoot) {
      // todo-00-last-last-last : think about this. This code requires that the root container builds the whole
      //  hierarchy when its buildContainerOrSelf is called. Is that guaranteed?
      selfOrReplacedWithContainer = buildContainerOrSelf(parentBoxContainer);
    }
    for (var child in selfOrReplacedWithContainer.children) {
      child.rootStep2_Recurse_buildContainerHierarchy(parentBoxContainer);
    }
  }
  */
#+END_SRC


** HOLD 3. Implement new Box/Column layouters

*** HOLD Implement ColumnLayouter similar to RowLayouter

Only needed later

*** HOLD (Likely NOT NEEDED) Consider if we should reverse the class hierarchy between ~BoxLayouter~ and ~BoxContainer~


- [X]  Currently: ~BoxContainer~ extends Object with ~BoxContainerHierarchy~, ~BoxLayouter~ implements ~LayoutableBox~ 
- [ ] Consider: ~BoxLayouter extends BoxContainer~. Below are some notes how it could be done
  - [ ] what methods or fields has BoxLayouter which BoxContainer does not have?
    - [ ] 
  - [ ] layout axis is already in Container, keep there for now
  - [ ] NO SPECIAL METHOD ADDED.
  - [ ] ~Add constructor BoxLayouter(children: List<BoxContainer>). How does it change what we are doing in BoxContainer?~
  - [ ] ~RowLayouter~
    - [ ] implement step301_IfNotLeafOffsetChildrenAndCheckIfMySizeFitWithinConstraints specifically.



** IN-PROGRESS 4. 2022-10-10 Review

*** Classes

*Legend classes for new layout*

Created in ChartRootContainer.layout():
- [X] LegendContainerOriginalKeep
- [X] LegendContainerNewKeep
  
Created in the above LegendContainerNewKeep.build  
- [X] LegendItemContainerOriginalKeep
- [X] LegendItemContainerNewKeep

Created in the above LegendItemContainerNewKeep.build  
- [X] LabelContainerOriginalKeep (used in both old LEGEND and AXIS labels)
- [X] LegendLabelContainerNewLegendSpecificKeep (copy of the above, used in new LEGEND)

Sibling to LegendLabelContainerNewLegendSpecificKeep  
- [X] LegendIndicatorRectContainer - NEW CLASS TO INDICATE LEGEND RECTANGLE.


*Container classes and structure (contained children created in build()):*

~LegendContainer~ contains ~LegendItemContainer~ contains ~LabelContainer~ AND ~LegendIndicatorRectContainer~ . ~LabelContainer~ contains ~TextPainter~

- abstract class ~LayoutableBox~ 
  - implementations:
    - mixin ~BoxLayouter~ on ~BoxContainerHierarchy~ implements ~LayoutableBox~
    - abstract class ~BoxContainer~ extends Object with ~BoxContainerHierarchy~, ~BoxLayouter~ implements ~LayoutableBox~ 


*** Sequence of calls to start layout

- ~FlutterChartPainter.paint~ calls
- ~ChartRootContainer.paint~ calls
- ~ChartRootContainer.layout~ which creates in order
- The ~LegendContainerNewKeep~, ~YContainer~, ~XContainer~ etc.
  - After each container is created, it's ~layout~ is immediately called.

    
IMPORTANT: ~BoxContainer~ extends ~BoxLayouter and BoxContainerHierarchy mixins~, ADDS METHODs ~paint(Canvas)~ and ~buildContainerOrSelf~ to ~BoxLayouter~

- [ ] Study LegendItemContainer Originalkeep and NewKeep
- [ ] last, there was an intent to experiment with some LegendItemContainer changes. Study differences between New and Original.


*** Questions to investigate
 
- [ ] On which interface is layout()?
- [ ] On which interface is newCoreLayout()?
- [ ] why do we have layout() and newCoreLayout()? - We want to use them simultaneously for some time
- [ ] BoxLayouter vs LayoutableBox:
  - ~LayoutableBox~:
    - abstract class which interface is implemented by *both* ~BoxLayouter~ and ~BoxContainer~
    #+begin_src dart
      abstract class LayoutableBox {
        ui.Size layoutSize = ui.Size.zero;
        void applyParentOffset(ui.Offset offset);
        _BoxLayouterLayoutSandbox layoutableBoxLayoutSandbox = _BoxLayouterLayoutSandbox();
        void newCoreLayout(BoxContainer parentBoxContainer);
    #+end_src 
    - [X] NOT a problem: ~ui.Size layoutSize~ is defined in both ~LayoutableBox~ and ~BoxLayouter~: NOT A PROBLEM, AS  ~BoxLayouter~ IMPLEMENTS  ~LayoutableBox~. IMPLEMENTS in Dart requires to re-implement all methods of the implemented class!!!
- [ ] 
- [ ] 
- [ ] 


- [ ] Study alignment and packing



** IN-PROGRESS 5. LEGEND LAYOUT: Use new Layouter algorithm + new Box/Column wrap ON LEGEND Containers (LegendContainer) instead of custom code. REST of Containers (*which??*) use original code.

*** IN-PROGRESS-NOW ~New Layout on Containers used in LEGEND = LegendContainer, LegendItemContainer, LabelContainer~

**** TODO Use RowLayouter in LegendContainer, LegendItemContainer, LabelContainer

*** NOTE Old Layout on REST of Containers - for now


** TODO-NEXT 6. REST Containers 1. : ~First migrate all remaining Containers to use new Layout methods, but still use manual layout NOT auto layout with RowLayouter and ColumnLayouter~

This section describes a first step of migrating a Container such as ~XLabelContainer~ - actually all Containers - to use the new layout ethods ~newCoreLayout()~ and ~buildContainerOrSelf~ *but still use manual layout AS IS* NOT auto layout with RowLayouter and ColumnLayouter.

*** TODO General notes on this migration

The old MANUAL ~layout(BoxContainerConstraints boxConstraints, BoxContainer parentBoxContainer)~ method typically does:

1. Use options and the available passed ~boxConstraints~ to manually divide space between children. The division results in 2 things for each child 
   1.1 The ~sizeOfChild~  = boxConstraints size divided into number oof children
   1.2 The ~offsetOfhild~ = sizeOfChild * indexOfChild in children array
2. children size one-by-one loop:
   - 2.0. create new ~childBoxConstraints~ object from ~sizeOfChild~,
the manually divided and allocated space for the child
   - 2.1 create new ~child~
   - 2.2 call ~child.layout(childBoxConstraints, this);~
   - 2.3 call ~child.applyParentOffset(offsetOfChild)~
   - 2.4 call ~addChild(child)~
3. set ~layoutSize~ = sum of sizes of all children in the layout direction, max child size in the cross-layout direction.

To migrate the code in the old MANUAL layout, do this:

1. Move one-by-one loop in ~2.1 and 2.4~ into  ~buildContainerOrSelf(BoxContainer parentBoxContainer)~
   - Notes:
     - The ~boxConstraints~ from the old layout code is replaced with ~parentBoxContainer.constraints~
2. Move code in ~1.1 and 1.2 and the one-by-one loop code in 2.0 and 2.2 and 2.3 and 3.~ into (overriden auto layout) method  ~newCoreLayout(parentBoxContainer)~
   - Notes:
     - When ~newCoreLayout~ called, the container hierarchy is already established from ~buildContainerOrSelf~. The one-by-one loop can be performed over children of 'this'.
     - Instead of 2.2 call to child.layout we call ~child.newCoreLayout(this)~


   
** TODO 7. REST Containers 2. : Use the new Layouter algorithm + new Box/Column layouts instead of custom code

*** LATER Ensure code sets up the parent/child hierarchy correctly in SOME existing containers

- [X] Which containers to convert to hierarchy?
  - [X] ~LegendContainer~ - contains LegendItemContainers children
    - Had member  ~_legendItemContainers~ for children. 
    - Children were managed in ~_legendItemContainers~. The changes replaced it with the ~children~ getter, and ~addChild~ , but also some code reordering, where addChild is called immediately after the child ~LegendItemContainer~ is created  
    - Removed member ~_legendItemContainers~
    - added ~addChild(legendItemContainer)~ after each new  legendItemContainer was created. Changed the order of code, as before, the add (to a private _legendItemContainers) was last.
  - [X] ~LegendItemContainer~ - contains ~LabelContainer~
    - Had single child member named ~_labelContainer~
    - Removed the single child, and started to use ~children~ to manage it instead of the single child member.
    - Replaced use of  ~_labelContainer~ with a single local  ~labelContainer~
  - [X] LabelContainer - has no container children, so no changes
- [ ] Next few containers
  - [ ] ~ChartTopContainer~
  - [ ] ~YContainer~
  - [ ] ~XContainer~
  - [ ] ~DataContainer~
- [ ] containers or container-like to leave for later.

*** TODO Todos for the Container deep refactoring to make "everything is a Container":

- [ ] All classes that are currently "container like" (extend ListBase) but do not extend Container, extend from Container. Must add 
  - [ ] First experiment on ~PresentersColumns~
- [ ] Find where Presenters get their internal values set
  - They are set in constructors, which are created during layout() of parents
  - For example, VerticalBarPresener constructor, all values (that is offsets) are established in Contructory, NOT in layout!
- [ ] Replace the above sites with calls to layout(maxSize: internal values from existing code);
- [ ] Convert to Containers
  - [ ] ~Presenter - VerticalBarPresenter, LineAndHotspotPresenter~
    - At which point does presenter gets size? ~when Presenter is created, it is passed StackableValuePoint, which contains the sizes~
    - VerticalBarPresenter({required StackableValuePoint point,
      - presentedRect = new ui.Rect.fromPoints(barLeftTop, barRightBottom); // so this is where the size is set!!!
    - LineAndHotspotpresenter
      - LineAndHotspotPresenter({  required StackableValuePoint point,
      - toPoint ??= fromPoint;
      - lineContainer = new LineContainer(
        lineFrom: fromPoint,
        lineTo: toPoint,
        linePaint: rowDataPaint..strokeWidth = options.lineStrokeWidth);
      - offsetPoint = fromPoint; // point is the left (from) end of the line
      - innerPaint = options.hotspotInnerPaint;
      - outerPaint = options.hotspotOuterPaint;
      - innerRadius = options.hotspotInnerRadius;
      - outerRadius = options.hotspotOuterRadius;
  - ~LineContainer (passed and living in LineAndHotspotPresenter) already extends Container!!~
    - class LineContainer extends flutter_charts_container.Container
  - ~ALL DRAWING ON CANVAS ARE ALREADY IN cONTAINERS. BUT THERE ARE OTHER OBJECTS IN BETWEEEN THOSE PAINTING CONTAINERS, ARE THOSE IN-BETWEEN ARE NOT CONTAINERS. WE HAVE TO CONVERT IN-BETWEEN TO CONTAINERS AS WELL~
    - ~The problem is, the presenters do not "paint/draw" themselves, but are drawn in parents~
      - ~VerticalBarChartDataContainer._drawDataPresentersColumns~
    - ~BUT WHERE ARE THE POSITIONS OF THE PRESENTORS INSIDES CALCULATED??~
      - ~CALCULATED IN ChartContainer.layout -> DataContainer.applyParentOffset -> DataContainer.setupPresentersColumns -> new PresentersColumns(pointsColumns: parentContainer.pointsColumns,~ 
      - So the calculation and drawing both happens in parents, NOT presenters.
 
- [ ] ~CONVERT THE IN-BETWEENS TO CONTAINERS, AND ITERATE THE layout and paint calls~
  - [ ] PointsColumn
  - [ ] PointsColumns
  - [ ] NOT StackableValuePoint
  - [ ] May need a special extension of Containers for some of the above.

    
*** TODO Maybe: Change AdjustableLabelsChartAreaContainer to a MIXIN.

AdjustableLabelsChartAreaContainer is just a marking class to hold _labelLayoutStrategy. We should not be adding class on the hierarchy to only hold some data - those should be mixins. Note: the only extension is XContainer
*** TODO LineContainer: Call layout as called on other containters, rather than rely on this.lineFrom and this.lineTo being changed in the constructor!!

- This is related to the fact that LineContainer.paint is just painting the  this.lineFrom and this.lineTo, so no layout is needed
  
*** TODO ~HUGE - establish hierarchy between current Containers children of ChartContainer~ 
*** TODO ~HUGE - establish hierarchy between current Containers other than children of ChartContainer~ (NOT non-container classes like Presenter, PointsColumn, PointsColumns )
